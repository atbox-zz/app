<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4ç¶­ç«‹æ–¹é«”å¯è¦–åŒ–æ•™å­¸</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(76, 201, 240, 0.3);
            border: 1px solid rgba(76, 201, 240, 0.2);
            transition: opacity 0.3s;
        }
        #info.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #info h1 {
            margin-top: 0;
            color: #4cc9f0;
            font-size: 1.5em;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(76, 201, 240, 0.3);
            border: 1px solid rgba(76, 201, 240, 0.2);
        }
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            background: linear-gradient(135deg, #4cc9f0 0%, #3aa8d0 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(76, 201, 240, 0.4);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 201, 240, 0.6);
        }
        button.active {
            background: linear-gradient(135deg, #f72585 0%, #d01257 100%);
            box-shadow: 0 4px 15px rgba(247, 37, 133, 0.4);
        }
        .step {
            margin-bottom: 15px;
            padding: 12px;
            border-left: 3px solid #4cc9f0;
            background: rgba(76, 201, 240, 0.1);
            border-radius: 4px;
        }
        .step h3 {
            margin-top: 0;
            color: #4cc9f0;
        }
        .highlight {
            color: #f72585;
            font-weight: bold;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 0.9em;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(76, 201, 240, 0.3);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.8);
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.8);
        }
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            font-size: 0.9em;
            border: 1px solid rgba(76, 201, 240, 0.2);
        }
        #stats h3 {
            margin-top: 0;
            color: #4cc9f0;
        }
        .toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 101;
            padding: 8px 15px;
            font-size: 0.9em;
        }
        label {
            margin: 0;
            white-space: nowrap;
        }
        #colorMode {
            padding: 8px 15px;
            border-radius: 6px;
            background: rgba(76, 201, 240, 0.2);
            border: 1px solid #4cc9f0;
            color: white;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <button class="toggle-btn" id="toggleInfo">éš±è—èª¬æ˜</button>
        
        <div id="info">
            <h1>4ç¶­ç«‹æ–¹é«”ï¼ˆè¶…ç«‹æ–¹é«”ï¼‰å¯è¦–åŒ–</h1>
            <div class="step">
                <h3>ğŸ“ ä»€éº¼æ˜¯4ç¶­ç«‹æ–¹é«”ï¼Ÿ</h3>
                <p>4ç¶­ç«‹æ–¹é«”ï¼ˆTesseract/è¶…ç«‹æ–¹é«”ï¼‰æ˜¯ç«‹æ–¹é«”åœ¨4ç¶­ç©ºé–“çš„æ“´å±•ï¼š</p>
                <ul>
                    <li><span class="highlight">16å€‹é ‚é»</span> - åº§æ¨™ç‚º (Â±1, Â±1, Â±1, Â±1)</li>
                    <li><span class="highlight">32æ¢é‚Š</span> - é€£æ¥ç›¸é„°é ‚é»</li>
                    <li><span class="highlight">24å€‹æ­£æ–¹å½¢é¢</span></li>
                    <li><span class="highlight">8å€‹ç«‹æ–¹é«”é‚Šç•Œ</span></li>
                </ul>
            </div>
            <div class="step">
                <h3>ğŸ‘ï¸ å¦‚ä½•ç†è§£æŠ•å½±ï¼Ÿ</h3>
                <p>å°±åƒ3Dç‰©é«”åœ¨2Då¹³é¢ä¸Šç”¢ç”Ÿé™°å½±ï¼Œ4Dè¶…ç«‹æ–¹é«”åœ¨3Dç©ºé–“ä¸­ç”¢ç”ŸæŠ•å½±ã€‚é€™å€‹å¯è¦–åŒ–å±•ç¤ºäº†è¶…ç«‹æ–¹é«”çš„3DæŠ•å½±ï¼Œä¸¦é€šé4ç¶­æ—‹è½‰å±•ç¤ºå…¶çµæ§‹ã€‚</p>
            </div>
            <div class="step">
                <h3>ğŸ® äº¤äº’èª¬æ˜</h3>
                <ul>
                    <li><strong>é¼ æ¨™æ‹–å‹•</strong> - æ—‹è½‰3Dè¦–è§’</li>
                    <li><strong>æ»¾è¼ª</strong> - ç¸®æ”¾</li>
                    <li><strong>æŒ‰éˆ•</strong> - åˆ‡æ›4Dæ—‹è½‰æ¨¡å¼</li>
                    <li><strong>æ»‘å¡Š</strong> - èª¿ç¯€æ—‹è½‰é€Ÿåº¦å’ŒæŠ•å½±è·é›¢</li>
                </ul>
            </div>
            <div class="step">
                <h3>ğŸŒˆ ç¶­åº¦ç†è§£</h3>
                <p><strong>0ç¶­</strong>: é» â†’ <strong>1ç¶­</strong>: ç·š â†’ <strong>2ç¶­</strong>: æ­£æ–¹å½¢ â†’ <strong>3ç¶­</strong>: ç«‹æ–¹é«” â†’ <strong>4ç¶­</strong>: è¶…ç«‹æ–¹é«”</p>
                <p>æ¯å¢åŠ ä¸€ç¶­ï¼Œå…ƒç´ æ•¸é‡éƒ½æœ‰è¦å¾‹åœ°å¢é•·ï¼</p>
            </div>
        </div>

        <div id="stats">
            <h3>çµ±è¨ˆä¿¡æ¯</h3>
            <p>é ‚é»: <span class="highlight">16</span></p>
            <p>é‚Š: <span class="highlight">32</span></p>
            <p>é¢: <span class="highlight">24</span></p>
            <p>ç«‹æ–¹é«”: <span class="highlight">8</span></p>
            <p style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(76, 201, 240, 0.3);">
                ç•¶å‰è§’åº¦:<br>
                XY: <span id="angleXY">0Â°</span><br>
                ZW: <span id="angleZW">0Â°</span><br>
                XW: <span id="angleXW">0Â°</span>
            </p>
        </div>

        <div id="controls">
            <div class="control-row">
                <button id="rotateXY">XYå¹³é¢æ—‹è½‰</button>
                <button id="rotateZW">ZWå¹³é¢æ—‹è½‰</button>
                <button id="rotateXW">XWå¹³é¢æ—‹è½‰</button>
            </div>
            <div class="control-row">
                <button id="rotateAll" class="active">è¤‡åˆæ—‹è½‰</button>
                <button id="pause">æš«åœ</button>
                <button id="reset">é‡ç½®</button>
            </div>
            <div class="control-row slider-container">
                <label>é€Ÿåº¦:</label>
                <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="1">
                <span id="speedValue">1.0x</span>
            </div>
            <div class="control-row slider-container">
                <label>æŠ•å½±è·é›¢:</label>
                <input type="range" id="distanceSlider" min="2" max="8" step="0.5" value="4">
                <span id="distanceValue">4.0</span>
            </div>
            <div class="control-row slider-container">
                <label>é¡è‰²æ¨¡å¼:</label>
                <select id="colorMode">
                    <option value="default">é»˜èª</option>
                    <option value="depth">æ·±åº¦æ¼¸è®Š</option>
                    <option value="rainbow">å½©è™¹</option>
                </select>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OrbitControls å…§è¯å¯¦ç¾
        THREE.OrbitControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.enabled = true;
            this.target = new THREE.Vector3();
            this.minDistance = 0;
            this.maxDistance = Infinity;
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            
            const scope = this;
            const EPS = 0.000001;
            const rotateStart = new THREE.Vector2();
            const rotateEnd = new THREE.Vector2();
            const rotateDelta = new THREE.Vector2();
            const spherical = new THREE.Spherical();
            const sphericalDelta = new THREE.Spherical();
            let scale = 1;
            const panOffset = new THREE.Vector3();
            let zoomChanged = false;
            
            const STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5 };
            let state = STATE.NONE;
            
            this.update = function() {
                const offset = new THREE.Vector3();
                const quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
                const quatInverse = quat.clone().invert();
                const lastPosition = new THREE.Vector3();
                const lastQuaternion = new THREE.Quaternion();
                
                return function update() {
                    const position = scope.camera.position;
                    offset.copy(position).sub(scope.target);
                    offset.applyQuaternion(quat);
                    spherical.setFromVector3(offset);
                    
                    if (scope.enableDamping) {
                        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                    } else {
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                    }
                    
                    spherical.phi = Math.max(EPS, Math.min(Math.PI - EPS, spherical.phi));
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    
                    scope.target.add(panOffset);
                    offset.setFromSpherical(spherical);
                    offset.applyQuaternion(quatInverse);
                    position.copy(scope.target).add(offset);
                    scope.camera.lookAt(scope.target);
                    
                    if (scope.enableDamping) {
                        sphericalDelta.theta *= (1 - scope.dampingFactor);
                        sphericalDelta.phi *= (1 - scope.dampingFactor);
                        panOffset.multiplyScalar(1 - scope.dampingFactor);
                    } else {
                        sphericalDelta.set(0, 0, 0);
                        panOffset.set(0, 0, 0);
                    }
                    
                    scale = 1;
                    
                    if (zoomChanged || lastPosition.distanceToSquared(scope.camera.position) > EPS || 
                        8 * (1 - lastQuaternion.dot(scope.camera.quaternion)) > EPS) {
                        lastPosition.copy(scope.camera.position);
                        lastQuaternion.copy(scope.camera.quaternion);
                        zoomChanged = false;
                        return true;
                    }
                    return false;
                };
            }();
            
            this.reset = function() {
                scope.target.set(0, 0, 0);
                scope.camera.position.set(0, 0, 5);
                scope.update();
            };
            
            function onMouseDown(e) {
                if (!scope.enabled) return;
                e.preventDefault();
                rotateStart.set(e.clientX, e.clientY);
                state = STATE.ROTATE;
                scope.domElement.addEventListener('mousemove', onMouseMove);
                scope.domElement.addEventListener('mouseup', onMouseUp);
            }
            
            function onMouseMove(e) {
                if (!scope.enabled) return;
                e.preventDefault();
                rotateEnd.set(e.clientX, e.clientY);
                rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(0.5);
                sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight;
                sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight;
                rotateStart.copy(rotateEnd);
                scope.update();
            }
            
            function onMouseUp() {
                scope.domElement.removeEventListener('mousemove', onMouseMove);
                scope.domElement.removeEventListener('mouseup', onMouseUp);
                state = STATE.NONE;
            }
            
            function onMouseWheel(e) {
                if (!scope.enabled) return;
                e.preventDefault();
                if (e.deltaY < 0) {
                    scale /= 0.95;
                } else if (e.deltaY > 0) {
                    scale *= 0.95;
                }
                scope.update();
            }
            
            this.domElement.addEventListener('mousedown', onMouseDown);
            this.domElement.addEventListener('wheel', onMouseWheel);
            this.update();
        };

        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.getElementById('container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        camera.position.z = 5;

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // 4Dé ‚é»
        const vertices4D = [];
        for (let i = 0; i < 16; i++) {
            vertices4D.push([
                (i & 1) ? 1 : -1,
                (i & 2) ? 1 : -1,
                (i & 4) ? 1 : -1,
                (i & 8) ? 1 : -1
            ]);
        }

        // é‚Š
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                let diff = 0;
                for (let k = 0; k < 4; k++) {
                    if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
                }
                if (diff === 1) edges.push([i, j]);
            }
        }

        // æŠ•å½±å‡½æ•¸
        let projectionDistance = 4;
        function project4DTo3D(v4d, angles) {
            let [x, y, z, w] = v4d;
            const [aXY, aZW, aXW] = angles;
            
            // XYæ—‹è½‰
            let x1 = x * Math.cos(aXY) - y * Math.sin(aXY);
            let y1 = x * Math.sin(aXY) + y * Math.cos(aXY);
            
            // ZWæ—‹è½‰
            let z2 = z * Math.cos(aZW) - w * Math.sin(aZW);
            let w2 = z * Math.sin(aZW) + w * Math.cos(aZW);
            
            // XWæ—‹è½‰
            let x3 = x1 * Math.cos(aXW) - w2 * Math.sin(aXW);
            let w3 = x1 * Math.sin(aXW) + w2 * Math.cos(aXW);
            
            // é€è¦–æŠ•å½±
            const scale = projectionDistance / (projectionDistance + w3);
            return new THREE.Vector3(x3 * scale, y1 * scale, z2 * scale);
        }

        // å¯è¦–åŒ–å°è±¡
        const verticesGroup = new THREE.Group();
        const edgesGroup = new THREE.Group();
        scene.add(verticesGroup);
        scene.add(edgesGroup);

        const vertexGeometry = new THREE.SphereGeometry(0.06, 16, 16);
        const vertexMeshes = [];
        const edgeLines = [];

        let colorMode = 'default';
        function getVertexColor(index) {
            if (colorMode === 'rainbow') {
                return new THREE.Color().setHSL(index / 16, 1, 0.5);
            } else if (colorMode === 'depth') {
                return new THREE.Color(0xf72585);
            }
            return new THREE.Color(0xf72585);
        }

        // å‰µå»ºé ‚é»
        for (let i = 0; i < 16; i++) {
            const mat = new THREE.MeshPhongMaterial({ 
                color: getVertexColor(i),
                emissive: getVertexColor(i),
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(vertexGeometry, mat);
            verticesGroup.add(mesh);
            vertexMeshes.push(mesh);
        }

        // å‰µå»ºé‚Š
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x4cc9f0, linewidth: 2 });
        for (let i = 0; i < edges.length; i++) {
            const geom = new THREE.BufferGeometry();
            const line = new THREE.Line(geom, edgeMaterial);
            edgesGroup.add(line);
            edgeLines.push(line);
        }

        // æ—‹è½‰ç‹€æ…‹
        let rotationAngles = [0, 0, 0];
        let rotationMode = 'all';
        let isPaused = false;
        let rotationSpeed = 1;

        function updateTesseract() {
            for (let i = 0; i < 16; i++) {
                const pos = project4DTo3D(vertices4D[i], rotationAngles);
                vertexMeshes[i].position.copy(pos);
                
                if (colorMode === 'depth') {
                    const depth = (pos.z + 2) / 4;
                    vertexMeshes[i].material.color.setHSL(0.55 + depth * 0.15, 0.8, 0.5);
                }
            }

            for (let i = 0; i < edges.length; i++) {
                const [si, ei] = edges[i];
                const sp = vertexMeshes[si].position;
                const ep = vertexMeshes[ei].position;
                const positions = new Float32Array([sp.x, sp.y, sp.z, ep.x, ep.y, ep.z]);
                edgeLines[i].geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            // æ›´æ–°è§’åº¦é¡¯ç¤º
            document.getElementById('angleXY').textContent = (rotationAngles[0] * 180 / Math.PI % 360).toFixed(0) + 'Â°';
            document.getElementById('angleZW').textContent = (rotationAngles[1] * 180 / Math.PI % 360).toFixed(0) + 'Â°';
            document.getElementById('angleXW').textContent = (rotationAngles[2] * 180 / Math.PI % 360).toFixed(0) + 'Â°';
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                const baseSpeed = 0.01 * rotationSpeed;
                if (rotationMode === 'xy') {
                    rotationAngles[0] += baseSpeed;
                } else if (rotationMode === 'zw') {
                    rotationAngles[1] += baseSpeed;
                } else if (rotationMode === 'xw') {
                    rotationAngles[2] += baseSpeed;
                } else if (rotationMode === 'all') {
                    rotationAngles[0] += baseSpeed * 0.5;
                    rotationAngles[1] += baseSpeed * 0.7;
                    rotationAngles[2] += baseSpeed * 0.3;
                }
            }
            
            updateTesseract();
            controls.update();
            renderer.render(scene, camera);
        }

        // äº‹ä»¶ç›£è½
        function setActiveButton(btn) {
            document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        document.getElementById('rotateXY').addEventListener('click', function() {
            rotationMode = 'xy';
            isPaused = false;
            setActiveButton(this);
        });

        document.getElementById('rotateZW').addEventListener('click', function() {
            rotationMode = 'zw';
            isPaused = false;
            setActiveButton(this);
        });

        document.getElementById('rotateXW').addEventListener('click', function() {
            rotationMode = 'xw';
            isPaused = false;
            setActiveButton(this);
        });

        document.getElementById('rotateAll').addEventListener('click', function() {
            rotationMode = 'all';
            isPaused = false;
            setActiveButton(this);
        });

        document.getElementById('pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'ç¹¼çºŒ' : 'æš«åœ';
            setActiveButton(this);
        });

        document.getElementById('reset').addEventListener('click', () => {
            rotationAngles = [0, 0, 0];
            controls.reset();
            rotationMode = 'all';
            isPaused = false;
            document.getElementById('pause').textContent = 'æš«åœ';
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = rotationSpeed.toFixed(1) + 'x';
        });

        document.getElementById('distanceSlider').addEventListener('input', (e) => {
            projectionDistance = parseFloat(e.target.value);
            document.getElementById('distanceValue').textContent = projectionDistance.toFixed(1);
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
            vertexMeshes.forEach((mesh, i) => {
                mesh.material.color = getVertexColor(i);
                mesh.material.emissive = getVertexColor(i);
            });
        });

        document.getElementById('toggleInfo').addEventListener('click', function() {
            const info = document.getElementById('info');
            info.classList.toggle('hidden');
            this.textContent = info.classList.contains('hidden') ? 'é¡¯ç¤ºèª¬æ˜' : 'éš±è—èª¬æ˜';
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateTesseract();
        animate();
    </script>
</body>
</html>