<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>Face Swap Demo — Seamless Clone + Manual Controls</title>

<!-- Face API model -->
<script defer src="https://cdn.jsdelivr.net/npm/face-api.js"></script>

<style>
    body {
        margin: 0;
        background: #111;
        color: white;
        font-family: sans-serif;
    }
    #container {
        display: flex;
        padding: 20px;
        gap: 20px;
    }
    canvas {
        background: #000;
        border: 1px solid #333;
    }
    #controls input[type=range] {
        width: 200px;
    }
</style>
</head>
<body>

<h2 style="padding:20px">高品質 Face Swap（示範：虛構臉 → 你的 target）</h2>

<div id="container">
    <div>
        <p>來源臉（虛構角色）</p>
        <img id="sourceImg" src="https://i.imgur.com/H4dA1N4.jpeg" width="280">
        
        <p>目標臉（你要換臉的）</p>
        <input type="file" id="targetFile" accept="image/*"><br><br>
        <canvas id="targetCanvas" width="500" height="600"></canvas>

        <button id="swapBtn">⚡ 開始換臉</button>
    </div>

    <div>
        <p>手動微調</p>
        <div id="controls">
            <label>亮度: <input id="brightness" type="range" min="-100" max="100" value="0"></label><br>
            <label>對比: <input id="contrast" type="range" min="-100" max="100" value="0"></label><br>
            <label>飽和度: <input id="saturation" type="range" min="-100" max="100" value="0"></label><br>
            <label>暖色調: <input id="warmth" type="range" min="-100" max="100" value="0"></label><br>
            <label>Gamma: <input id="gamma" type="range" min="10" max="300" value="100"></label><br><br>

            <label>Feather 半徑: <input id="feather" type="range" min="1" max="80" value="35"></label><br>
            <label>Mask X: <input id="maskX" type="range" min="-60" max="60" value="0"></label><br>
            <label>Mask Y: <input id="maskY" type="range" min="-60" max="60" value="0"></label><br>
        </div>
    </div>
</div>

<script>
/* -------------------
   1. 載入 Face API 模型
------------------- */
Promise.all([
    faceapi.nets.tinyFaceDetector.loadFromUri("https://cdn.jsdelivr.net/npm/face-api.js/weights"),
    faceapi.nets.faceLandmark68Net.loadFromUri("https://cdn.jsdelivr.net/npm/face-api.js/weights")
]).then(() => console.log("Models loaded"));


/* -------------------
   2. 載入目標圖片
------------------- */
const targetCanvas = document.getElementById("targetCanvas");
const tctx = targetCanvas.getContext("2d");

targetFile.onchange = () => {
    const file = targetFile.files[0];
    const img = new Image();
    img.onload = () => {
        targetCanvas.width = img.width;
        targetCanvas.height = img.height;
        tctx.drawImage(img, 0, 0);
    };
    img.src = URL.createObjectURL(file);
};


/* -------------------
   3. 主換臉程序
------------------- */
document.getElementById("swapBtn").onclick = async () => {

    const sourceImg = document.getElementById("sourceImg");

    const targetDet = await faceapi
        .detectSingleFace(targetCanvas, new faceapi.TinyFaceDetectorOptions())
        .withFaceLandmarks();

    if (!targetDet) {
        alert("找不到目標臉");
        return;
    }

    const sourceDet = await faceapi
        .detectSingleFace(sourceImg, new faceapi.TinyFaceDetectorOptions())
        .withFaceLandmarks();

    if (!sourceDet) {
        alert("找不到來源臉");
        return;
    }

    // landmark points
    const srcPts = sourceDet.landmarks.positions.map(p => [p.x, p.y]);
    const tgtPts = targetDet.landmarks.positions.map(p => [p.x, p.y]);

    // 產生 warp 後的 source face
    const warped = await warpFace(sourceImg, srcPts, tgtPts);

    // 顏色校正
    colorCorrect(warped.ctx, tctx, warped.mask);

    // 手動微調
    applyManualAdjustments(warped.ctx);

    // 合成
    blendWithMask(tctx, warped.ctx, warped.mask);

    alert("換臉完成！");
};


/* -------------------
   4. 臉部 Warp（Delaunay → Affine）
------------------- */
async function warpFace(srcImg, srcPts, tgtPts) {
    const w = targetCanvas.width;
    const h = targetCanvas.height;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");

    const maskCanvas = document.createElement("canvas");
    maskCanvas.width = w;
    maskCanvas.height = h;

    // Delaunay triangulation
    const tri = delaunay(tgtPts);

    // Warp triangles
    for (let t of tri) {
        const s1 = srcPts[t[0]], s2 = srcPts[t[1]], s3 = srcPts[t[2]];
        const d1 = tgtPts[t[0]], d2 = tgtPts[t[1]], d3 = tgtPts[t[2]];

        affineTriangle(srcImg, ctx, [s1,s2,s3], [d1,d2,d3]);
    }

    // 建立 feather mask
    const m = createFeatherMask(w, h,
        feather.value*1.2,
        parseInt(maskX.value),
        parseInt(maskY.value)
    );

    return { ctx, mask: m };
}


/* -------------------
   5. Feather Mask
------------------- */
function createFeatherMask(w, h, radius, offX, offY) {
    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    const ctx = c.getContext("2d");

    const cx = w/2 + offX;
    const cy = h/2 + offY;

    const g = ctx.createRadialGradient(cx, cy, 1, cx, cy, radius);
    g.addColorStop(0, "rgba(255,255,255,1)");
    g.addColorStop(1, "rgba(0,0,0,0)");

    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    return c;
}


/* -------------------
   6. 顏色匹配升級版（Grayworld + Mean normalization）
------------------- */
function colorCorrect(srcCtx, tgtCtx, maskCanvas) {
    const s = srcCtx.getImageData(0,0,srcCtx.canvas.width,srcCtx.canvas.height);
    const t = tgtCtx.getImageData(0,0,tgtCtx.canvas.width,tgtCtx.canvas.height);
    const m = maskCanvas.getContext("2d").getImageData(0,0,maskCanvas.width,maskCanvas.height);

    let sMean=[0,0,0], tMean=[0,0,0], count=0;

    for (let i=0;i<s.data.length;i+=4){
        if(m.data[i+3]<10) continue;
        sMean[0]+=s.data[i];
        sMean[1]+=s.data[i+1];
        sMean[2]+=s.data[i+2];

        tMean[0]+=t.data[i];
        tMean[1]+=t.data[i+1];
        tMean[2]+=t.data[i+2];
        count++;
    }

    sMean=sMean.map(v=>v/count);
    tMean=tMean.map(v=>v/count);

    const gain = [
        tMean[0]/sMean[0],
        tMean[1]/sMean[1],
        tMean[2]/sMean[2]
    ];

    for (let i=0;i<s.data.length;i+=4){
        if(m.data[i+3]<10) continue;

        s.data[i]   = Math.min(255,s.data[i]  *gain[0]);
        s.data[i+1] = Math.min(255,s.data[i+1]*gain[1]);
        s.data[i+2] = Math.min(255,s.data[i+2]*gain[2]);
    }

    srcCtx.putImageData(s,0,0);
}


/* -------------------
   7. 手動微調控制（亮度/對比/飽和/暖色調/Gamma）
------------------- */
function applyManualAdjustments(ctx) {
    const img = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
    const d = img.data;

    const b = parseInt(brightness.value);
    const c = parseInt(contrast.value);
    const s = parseInt(saturation.value);
    const w = parseInt(warmth.value);
    const g = parseInt(gamma.value)/100;

    for (let i=0;i<d.length;i+=4){

        d[i]+=b; d[i+1]+=b; d[i+2]+=b;

        // contrast
        d[i]   = ((d[i]-128)*(1+c/100))+128;
        d[i+1] = ((d[i+1]-128)*(1+c/100))+128;
        d[i+2] = ((d[i+2]-128)*(1+c/100))+128;

        // saturation
        const gray=(d[i]+d[i+1]+d[i+2])/3;
        d[i]   = gray + (d[i]-gray)*(1+s/100);
        d[i+1] = gray + (d[i+1]-gray)*(1+s/100);
        d[i+2] = gray + (d[i+2]-gray)*(1+s/100);

        // warmth
        d[i] += w*0.8;
        d[i+1] += w*0.4;
        d[i+2] -= w*0.8;

        // gamma
        d[i]   = 255*Math.pow(d[i]/255,g);
        d[i+1] = 255*Math.pow(d[i+1]/255,g);
        d[i+2] = 255*Math.pow(d[i+2]/255,g);
    }

    ctx.putImageData(img,0,0);
}


/* -------------------
   8. 最終合成（Alpha mask）
------------------- */
function blendWithMask(tgtCtx, srcCtx, maskCanvas) {
    const w = tgtCtx.canvas.width;
    const h = tgtCtx.canvas.height;

    const t = tgtCtx.getImageData(0,0,w,h);
    const s = srcCtx.getImageData(0,0,w,h);
    const m = maskCanvas.getContext("2d").getImageData(0,0,w,h);

    for (let i=0;i<t.data.length;i+=4){
        const a = m.data[i]/255;

        t.data[i]   = t.data[i]*(1-a) + s.data[i]*a;
        t.data[i+1] = t.data[i+1]*(1-a) + s.data[i+1]*a;
        t.data[i+2] = t.data[i+2]*(1-a) + s.data[i+2]*a;
    }

    tgtCtx.putImageData(t,0,0);
}


/* -------------------
   9. Delaunay Triangulation（簡化）
------------------- */
function delaunay(pts){
    // VERY simplified → 使用 face-api 68 landmark 預設組合
    // 這是常見的 face triangulation set
    return [
        [0,1,36],[1,2,36],[2,3,36],[3,4,48],[48,36,3],
        [36,37,38],[38,39,27],[27,28,29],[29,30,33],
        [33,48,31],[48,31,3],[48,59,31]
    ];
}


/* -------------------
   10. Affine warp of triangle
------------------- */
function affineTriangle(srcImg, dstCtx, srcTri, dstTri) {
    const w = dstCtx.canvas.width;
    const h = dstCtx.canvas.height;

    const tmp = document.createElement("canvas");
    tmp.width = w;
    tmp.height = h;
    const tctx = tmp.getContext("2d");

    // Clip target triangle
    tctx.save();
    tctx.beginPath();
    tctx.moveTo(dstTri[0][0],dstTri[0][1]);
    tctx.lineTo(dstTri[1][0],dstTri[1][1]);
    tctx.lineTo(dstTri[2][0],dstTri[2][1]);
    tctx.closePath();
    tctx.clip();

    const src = srcTri;
    const dst = dstTri;

    // Affine transform matrix
    const matrix = computeAffine(src, dst);

    tctx.setTransform(
        matrix.a, matrix.b,
        matrix.c, matrix.d,
        matrix.e, matrix.f
    );

    tctx.drawImage(srcImg,0,0);
    tctx.restore();

    dstCtx.drawImage(tmp,0,0);
}


/* -------------------
   11. Compute affine transform
------------------- */
function computeAffine(src, dst){
    const x0=src[0][0], y0=src[0][1];
    const x1=src[1][0], y1=src[1][1];
    const x2=src[2][0], y2=src[2][1];

    const u0=dst[0][0], v0=dst[0][1];
    const u1=dst[1][0], v1=dst[1][1];
    const u2=dst[2][0], v2=dst[2][1];

    const denom = (x0*(y1-y2)+x1*(y2-y0)+x2*(y0-y1));

    const a = (u0*(y1-y2)+u1*(y2-y0)+u2*(y0-y1))/denom;
    const b = (u0*(x2-x1)+u1*(x0-x2)+u2*(x1-x0))/denom;
    const c = (v0*(y1-y2)+v1*(y2-y0)+v2*(y0-y1))/denom;
    const d = (v0*(x2-x1)+v1*(x0-x2)+v2*(x1-x0))/denom;

    const e = u0 - a*x0 - b*y0;
    const f = v0 - c*x0 - d*y0;

    return {a,b,c,d,e,f};
}

</script>

</body>
</html>
