<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>3×3 魔術方塊｜旋轉示意＋公式速查＋回放功能</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  color: #333;
}

.app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

header {
  text-align: center;
  margin-bottom: 30px;
}

header h1 {
  color: white;
  font-size: 2.5rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  margin-bottom: 10px;
}

.main-container {
  display: grid;
  grid-template-columns: 1fr 400px;
  gap: 30px;
  align-items: start;
}

@media (max-width: 768px) {
  .main-container {
    grid-template-columns: 1fr;
    gap: 20px;
  }
}

.viewer {
  background: rgba(255,255,255,0.95);
  border-radius: 20px;
  padding: 30px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  backdrop-filter: blur(10px);
}

.stage {
  position: relative;
  height: 400px;
  perspective: 1000px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cube-wrap {
  position: relative;
  width: 200px;
  height: 200px;
  cursor: grab;
  user-select: none;
}

.cube-wrap:active {
  cursor: grabbing;
}

.cube {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.3s ease;
}

.face {
  position: absolute;
  width: 200px;
  height: 200px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 2px;
  padding: 8px;
  background: #222;
  border-radius: 8px;
}

.face--F { transform: rotateY(0deg) translateZ(100px); }
.face--B { transform: rotateY(180deg) translateZ(100px); }
.face--U { transform: rotateX(90deg) translateZ(100px); }
.face--D { transform: rotateX(-90deg) translateZ(100px); }
.face--R { transform: rotateY(90deg) translateZ(100px); }
.face--L { transform: rotateY(-90deg) translateZ(100px); }

.sticker {
  border-radius: 4px;
  border: 1px solid rgba(0,0,0,0.2);
  box-shadow: inset 0 1px 2px rgba(255,255,255,0.3);
  transition: all 0.2s ease;
}

.hud {
  position: absolute;
  top: 20px;
  left: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.chip {
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 12px;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 500;
}

.btn {
  background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
  color: white;
  border: none;
  padding: 10px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 600;
  transition: all 0.2s ease;
  box-shadow: 0 4px 15px rgba(238, 90, 111, 0.3);
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(238, 90, 111, 0.4);
}

.btn:active {
  transform: translateY(0);
}

.panel {
  background: rgba(255,255,255,0.95);
  border-radius: 20px;
  padding: 30px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  backdrop-filter: blur(10px);
  max-height: 600px;
  overflow-y: auto;
}

.panel h2 {
  color: #333;
  margin-bottom: 20px;
  font-size: 1.5rem;
  text-align: center;
}

.algo {
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 15px;
  border-left: 4px solid #667eea;
  transition: all 0.2s ease;
}

.algo:hover {
  transform: translateX(5px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.algo h3 {
  color: #495057;
  margin-bottom: 10px;
  font-size: 1rem;
}

.algo pre {
  background: #2d3748;
  color: #e2e8f0;
  padding: 12px;
  border-radius: 8px;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.4;
  margin-bottom: 10px;
  letter-spacing: 1px;
}

.play-btn {
  background: linear-gradient(45deg, #4ecdc4, #44a08d);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.85rem;
  font-weight: 600;
  transition: all 0.2s ease;
  box-shadow: 0 3px 10px rgba(68, 160, 141, 0.3);
}

.play-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 5px 15px rgba(68, 160, 141, 0.4);
}

.play-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.controls {
  margin-top: 20px;
  text-align: center;
}

.speed-control {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-bottom: 10px;
}

.speed-control label {
  font-size: 0.9rem;
  color: #666;
}

.speed-control input {
  width: 100px;
}

.status {
  background: rgba(52, 152, 219, 0.1);
  border: 1px solid rgba(52, 152, 219, 0.3);
  border-radius: 8px;
  padding: 10px;
  margin-top: 10px;
  color: #2980b9;
  font-size: 0.9rem;
  min-height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.moves {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin: 16px 0;
  justify-content: center;
}

.move {
  padding: 8px 12px;
  border-radius: 10px;
  background: rgba(255,255,255,.8);
  border: 2px solid rgba(102,126,234,0.2);
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.2s ease;
  color: #333;
}

.move.active {
  background: #667eea;
  color: white;
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(102,126,234,0.4);
}

.playback-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
  padding: 15px;
  background: rgba(102,126,234,0.1);
  border-radius: 12px;
  margin-top: 16px;
  flex-wrap: wrap;
}

.custom-input {
  width: 100%;
  padding: 10px;
  border: 2px solid rgba(102,126,234,0.3);
  border-radius: 8px;
  font-size: 14px;
  margin: 10px 0;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}

.custom-input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
}

/* 滾動條樣式 */
.panel::-webkit-scrollbar {
  width: 6px;
}

.panel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.1);
  border-radius: 3px;
}

.panel::-webkit-scrollbar-thumb {
  background: rgba(102, 126, 234, 0.3);
  border-radius: 3px;
}

.panel::-webkit-scrollbar-thumb:hover {
  background: rgba(102, 126, 234, 0.5);
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>3×3 魔術方塊｜旋轉示意＋公式速查＋回放功能</h1>
</header>

<div class="main-container">
  <section class="viewer">
    <div class="stage">
      <div class="cube-wrap" id="cubeWrap">
        <div class="cube" id="cube"></div>
      </div>
      <div class="hud">
        <span class="chip" id="angleReadout">旋轉：0°, 0°</span>
        <button class="btn" id="resetBtn">重置視角</button>
      </div>
    </div>
  </section>

  <main class="panel" id="formulaPanel">
    <h2>🎯 經典公式速查</h2>
    
    <div class="controls">
      <div class="speed-control">
        <label>播放速度:</label>
        <input type="range" id="speedSlider" min="200" max="1000" value="600" step="100">
        <span id="speedValue">600ms</span>
      </div>
    </div>
    
    <div class="status" id="statusDisplay">
      選擇一個公式開始回放動畫
    </div>

    <div id="movesContainer" class="moves"></div>
    
    <div class="playback-controls">
      <button class="btn" id="pauseBtn">⏸ 暫停</button>
      <button class="btn" id="stopBtn">⏹ 停止</button>
    </div>

    <input type="text" id="customAlgo" class="custom-input" placeholder="輸入自訂公式，例如: R U R' U' F' U F">
    <div style="text-align: center; margin-top: 10px;">
      <button class="btn" id="playCustom">播放自訂公式</button>
    </div>
  </main>
</div>

</div>
// ----------------- 初始化貼紙 DOM -----------------
(function buildCube(){
  const palette = {
    standard: {U:'#f8fafc', D:'#facc15', F:'#16a34a', B:'#2563eb', L:'#f97316', R:'#e11d48'},
    highcontrast: {U:'#ffffff', D:'#ffd166', F:'#0ea5a4', B:'#1e3a8a', L:'#fb923c', R:'#ef4444'},
    mono: {U:'#f3f4f6', D:'#d1d5db', F:'#bfc7cf', B:'#9aa6b2', L:'#8b8b8b', R:'#a3a3a3'}
  };

  // 魔方狀態引擎：每個面 3x3 陣列，使用顏色代碼
  window.cubeState = {
    U: Array.from({length: 3}, () => Array(3).fill('U')),
    D: Array.from({length: 3}, () => Array(3).fill('D')),
    F: Array.from({length: 3}, () => Array(3).fill('F')),
    B: Array.from({length: 3}, () => Array(3).fill('B')),
    L: Array.from({length: 3}, () => Array(3).fill('L')),
    R: Array.from({length: 3}, () => Array(3).fill('R'))
  };

  const cube = document.getElementById('cube');
  cube.innerHTML = '';
  ['F', 'B', 'U', 'D', 'R', 'L'].forEach(faceKey => {
    const face = document.createElement('div');
    face.className = 'face face--' + faceKey;
    face.dataset.face = faceKey;
    for (let i = 0; i < 9; i++) {
      const s = document.createElement('div');
      s.className = 'sticker';
      s.dataset.idx = i;
      face.appendChild(s);
    }
    cube.appendChild(face);
  });

  // 更新貼紙顏色根據狀態和配色
  window.updateStickers = function() {
    const currentPalette = palette[document.getElementById('paletteSelect').value] || palette.standard;
    document.querySelectorAll('.face').forEach(face => {
      const faceKey = face.dataset.face;
      const stickers = face.children;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const idx = i * 3 + j;
          const colorKey = cubeState[faceKey][i][j];
          stickers[idx].style.background = currentPalette[colorKey];
        }
      }
    });
  };

  // 應用配色（現在與狀態整合）
  window._paletteApply = function(name = 'standard') {
    updateStickers();
  };

  updateStickers(); // 初始更新
})();

// ----------------- 旋轉互動 -----------------
(function(){
  // ... (原程式碼保持不變)
})();

// ----------------- 視覺設定 控制 -----------------
(function(){
  // ... (原程式碼保持不變)
  // 添加：配色變更後更新貼紙
  paletteSelect.addEventListener('change', e => {
    window._paletteApply(e.target.value);
  });
  resetColors.addEventListener('click', () => {
    paletteSelect.value = 'standard';
    window._paletteApply('standard');
  });
})();

// ----------------- 複製按鈕 -----------------
(function(){
  // ... (原程式碼保持不變)
})();

// ----------------- 狀態引擎：旋轉單一面 -----------------
function rotateFace(face, clockwise = true) {
  const newFace = Array.from({length: 3}, () => Array(3).fill(null));
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (clockwise) {
        newFace[j][2 - i] = face[i][j];
      } else {
        newFace[2 - j][i] = face[i][j];
      }
    }
  }
  return newFace;
}

// ----------------- 狀態引擎：循環相鄰邊緣 -----------------
function cycleForMove(faceLetter) {
  const cs = cubeState;
  switch (faceLetter) {
    case 'R':
      let temp = cs.U.map(row => row[2]); // U right
      let bLeft = [cs.B[0][0], cs.B[1][0], cs.B[2][0]].reverse();
      cs.U[0][2] = bLeft[0]; cs.U[1][2] = bLeft[1]; cs.U[2][2] = bLeft[2];
      let dRight = [cs.D[0][2], cs.D[1][2], cs.D[2][2]].reverse();
      cs.B[0][0] = dRight[0]; cs.B[1][0] = dRight[1]; cs.B[2][0] = dRight[2];
      let fRight = [cs.F[0][2], cs.F[1][2], cs.F[2][2]];
      cs.D[0][2] = fRight[0]; cs.D[1][2] = fRight[1]; cs.D[2][2] = fRight[2];
      cs.F[0][2] = temp[0]; cs.F[1][2] = temp[1]; cs.F[2][2] = temp[2];
      break;
    case 'L':
      let tempL = cs.U.map(row => row[0]); // U left
      let bRight = [cs.B[0][2], cs.B[1][2], cs.B[2][2]].reverse();
      cs.U[0][0] = bRight[0]; cs.U[1][0] = bRight[1]; cs.U[2][0] = bRight[2];
      let dLeft = [cs.D[0][0], cs.D[1][0], cs.D[2][0]].reverse();
      cs.B[0][2] = dLeft[0]; cs.B[1][2] = dLeft[1]; cs.B[2][2] = dLeft[2];
      let fLeft = [cs.F[0][0], cs.F[1][0], cs.F[2][0]];
      cs.D[0][0] = fLeft[0]; cs.D[1][0] = fLeft[1]; cs.D[2][0] = fLeft[2];
      cs.F[0][0] = tempL[0]; cs.F[1][0] = tempL[1]; cs.F[2][0] = tempL[2];
      break;
    case 'U':
      let tempU = cs.F[0].slice(); // F top
      let lTop = cs.L[0].slice();
      cs.F[0][0] = lTop[0]; cs.F[0][1] = lTop[1]; cs.F[0][2] = lTop[2];
      let bTop = cs.B[0].slice();
      cs.L[0][0] = bTop[0]; cs.L[0][1] = bTop[1]; cs.L[0][2] = bTop[2];
      let rTop = cs.R[0].slice();
      cs.B[0][0] = rTop[0]; cs.B[0][1] = rTop[1]; cs.B[0][2] = rTop[2];
      cs.R[0][0] = tempU[0]; cs.R[0][1] = tempU[1]; cs.R[0][2] = tempU[2];
      break;
    case 'D':
      let tempD = cs.F[2].slice(); // F bottom
      let rBottom = cs.R[2].slice();
      cs.F[2][0] = rBottom[0]; cs.F[2][1] = rBottom[1]; cs.F[2][2] = rBottom[2];
      let bBottom = cs.B[2].slice();
      cs.R[2][0] = bBottom[0]; cs.R[2][1] = bBottom[1]; cs.R[2][2] = bBottom[2];
      let lBottom = cs.L[2].slice();
      cs.B[2][0] = lBottom[0]; cs.B[2][1] = lBottom[1]; cs.B[2][2] = lBottom[2];
      cs.L[2][0] = tempD[0]; cs.L[2][1] = tempD[1]; cs.L[2][2] = tempD[2];
      break;
    case 'F':
      let tempF = cs.U[2].slice(); // U bottom
      let lRight = [cs.L[0][2], cs.L[1][2], cs.L[2][2]].reverse();
      cs.U[2][0] = lRight[0]; cs.U[2][1] = lRight[1]; cs.U[2][2] = lRight[2];
      let dTop = cs.D[0].slice().reverse();
      cs.L[0][2] = dTop[0]; cs.L[1][2] = dTop[1]; cs.L[2][2] = dTop[2];
      let rLeft = [cs.R[0][0], cs.R[1][0], cs.R[2][0]];
      cs.D[0][0] = rLeft[0]; cs.D[0][1] = rLeft[1]; cs.D[0][2] = rLeft[2];
      cs.R[0][0] = tempF[0]; cs.R[1][0] = tempF[1]; cs.R[2][0] = tempF[2];
      break;
    case 'B':
      let tempB = cs.U[0].slice(); // U top
      let rRight = [cs.R[0][2], cs.R[1][2], cs.R[2][2]].reverse();
      cs.U[0][0] = rRight[0]; cs.U[0][1] = rRight[1]; cs.U[0][2] = rRight[2];
      let dBottom = cs.D[2].slice().reverse();
      cs.R[0][2] = dBottom[0]; cs.R[1][2] = dBottom[1]; cs.R[2][2] = dBottom[2];
      let lLeft = [cs.L[0][0], cs.L[1][0], cs.L[2][0]];
      cs.D[2][0] = lLeft[0]; cs.D[2][1] = lLeft[1]; cs.D[2][2] = lLeft[2];
      cs.L[0][0] = tempB[0]; cs.L[1][0] = tempB[1]; cs.L[2][0] = tempB[2];
      break;
  }
}

// ----------------- 狀態引擎：應用單一移動 -----------------
function applyMove(move) {
  const faceLetter = move.replace(/'|\d/, '');
  let turns = 1;
  let clockwise = true;
  if (move.includes("'")) {
    turns = 1;
    clockwise = false;
  } else if (move.includes('2')) {
    turns = 2;
  }

  // 旋轉面
  for (let t = 0; t < turns; t++) {
    cubeState[faceLetter] = rotateFace(cubeState[faceLetter], clockwise);
  }

  // 循環邊緣
  let cycleTurns = turns;
  if (!clockwise) {
    cycleTurns = 3; // 逆時針 = 順時針 3 次 (因為 4 次 = 身份)
  }
  for (let t = 0; t < cycleTurns; t++) {
    cycleForMove(faceLetter);
  }
}

// ----------------- 播放引擎（現在使用真實狀態） -----------------
let playState = {timer:null, idx:0, seq:[], running:false, paused:false};
const movesContainer = document.getElementById('movesContainer');
const speedRange = document.getElementById('speedRange');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');

function normalizeMoves(arr){
  return arr.map(s=>s.trim()).filter(Boolean).map(s=>s.replace(/\u2019/g, "'").replace(/–/g,'-'));
}

function renderMoves(seq){ movesContainer.innerHTML = ''; seq.forEach((m,i)=>{ const el=document.createElement('div'); el.className='move'; el.textContent = m; el.dataset.idx=i; movesContainer.appendChild(el); }); }

function highlight(idx){ Array.from(movesContainer.children).forEach(ch=>ch.classList.toggle('active', Number(ch.dataset.idx)===idx)); }

function applyVisualMove(move){
  // 原視覺效果（整體旋轉）
  const cube = document.getElementById('cube');
  const orig = cube.style.transform;
  const ang = 90; let tx=0, ty=0, tz=0;
  if(/^R/.test(move)) { ty += -20; }
  else if(/^L/.test(move)) { ty += 20; }
  else if(/^U/.test(move)) { tx += 20; }
  else if(/^D/.test(move)) { tx += -20; }
  else if(/^F/.test(move)) { tz += 0; tx += -10; }
  else if(/^B/.test(move)) { tz += 0; tx += 10; }
  if(move.includes("'")) { tx *= -1; ty *= -1; }
  if(move.includes('2')) { tx *= 1.6; ty *= 1.6; }

  cube.style.transition = 'transform 180ms ease';
  cube.style.transform = `rotateX(${tx}deg) rotateY(${ty}deg) scale(1)`;
  setTimeout(() => { cube.style.transform = orig; cube.style.transition = 'transform 120ms ease'; }, 220);

  // 新增：應用真實轉動並更新貼紙
  applyMove(move);
  updateStickers();
}

async function playSequence(seqRaw){
  const seq = normalizeMoves(seqRaw);
  if(seq.length===0) return;
  if(playState.running) stopPlayback();
  playState.seq = seq; playState.idx = 0; playState.running = true; playState.paused = false;
  renderMoves(seq); highlight(0);
  const delay = ()=>Number(speedRange.value);
  while(playState.idx < seq.length && playState.running){
    if(playState.paused){ await new Promise(r=>setTimeout(r,80)); continue; }
    const m = seq[playState.idx]; highlight(playState.idx); applyVisualMove(m);
    await new Promise(r=>setTimeout(r, delay()));
    playState.idx++;
  }
  playState.running = false;
}

function stopPlayback(){ playState.running=false; playState.paused=false; playState.idx=0; highlight(-1); }
pauseBtn.addEventListener('click', ()=>{ if(!playState.running) return; playState.paused = !playState.paused; pauseBtn.textContent = playState.paused? '繼續' : '暫停'; });
stopBtn.addEventListener('click', ()=>{ stopPlayback(); });

document.getElementById('playCustom').addEventListener('click', ()=>{ const v=document.getElementById('customAlgo').value; if(!v) return; playSequence(v.split(/\s+|,\s*/)); });
document.getElementById('copyCustom').addEventListener('click', async ()=>{ const v=document.getElementById('customAlgo').value; try{ await navigator.clipboard.writeText(v); alert('已複製'); }catch{ alert('複製失敗'); } });

// small utility: playSequence from other handlers
window.playSequence = playSequence;

// stop on page hide
window.addEventListener('pagehide', ()=>stopPlayback());