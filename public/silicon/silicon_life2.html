<!DOCTYPE html>
<html>
<head>
    <title>çŸ½åŸºç”Ÿå‘½æ¼”åŒ–æ¨¡æ“¬ - ASAL äº¤äº’å¢å¼·ç‰ˆ</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #0a0a0a; color: white; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        #stage-title { font-weight: bold; margin-bottom: 5px; }
        #chemical-formula { color: #ADD8E6; margin: 10px 0; font-size: 1.1em; } 
        .param-value { color: #f0e68c; } 
    </style>
</head>
<body>
    <div id="info">
        <div id="chemical-formula"></div>
        <div id="stage-title">ç•¶å‰éšæ®µ: æº–å‚™å•Ÿå‹•</div>
        <div id="life-count">ç”Ÿå‘½é«”æ•¸é‡: <span id="life-count-value" class="param-value">0</span></div>
        <div id="energy-level">ç’°å¢ƒèƒ½é‡: <span id="energy-level-value" class="param-value">ä½</span></div>
        <div id="si-p-ratio">Si/P æ´»æ€§æ¯”: <span id="si-p-ratio-value" class="param-value">ä½</span></div>
        <div id="elapsed-time">é‹è¡Œæ™‚é–“: <span id="elapsed-time-value" class="param-value">0.00 ç§’</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // **********************************************
        // Three.js çŸ½åŸºç”Ÿå‘½æ¼”åŒ–æ¨¡æ“¬æ ¸å¿ƒè…³æœ¬ (æœ€çµ‚ ASAL äº¤äº’å¢å¼·ç‰ˆ)
        // **********************************************

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer, clock, light;
        let lifeForms = []; 
        let evolutionStage = 1; 
        const STAGE_DURATION = 25; 
        const MAX_LIFE_FORMS = 500; 

        // --- éšæ®µä¸€æ§åˆ¶è®Šæ•¸ ---
        const INITIAL_HOLD_TIME = 3; // åˆå§‹ä¿æŒéœæ­¢çš„æ™‚é–“ (ç§’)
        let expansionStarted = false; // ç”Ÿå‘½æ“´å¼µæ˜¯å¦å·²é–‹å§‹
        let isExpanding = false; // æ­£åœ¨é€²è¡Œæ“´å¼µçš„æ——æ¨™

        // --- DOM å…ƒç´ è®Šæ•¸ ---
        let stageTitleElement, lifeCountValueElement, elapsedTimeValueElement, energyLevelValueElement, siPRatioValueElement, chemicalFormulaElement;
        
        // ç’°å¢ƒåƒæ•¸ 
        let environmentEnergy = 0.2; 
        let siPRatio = 0.1; 

        // --- çŸ½åŸºç”Ÿå‘½ç²’å­é¡åˆ¥ ---
        class SiliconLife {
            constructor(id, position, genes = Math.random()) {
                this.id = id;
                this.genes = genes; 
                this.mesh = this.createMesh(position);
                this.age = 0; 
                this.health = 1.0; 
                this.type = 'Silane'; 
                this.target = new THREE.Vector3().copy(position); 
                this.isPredator = this.genes > 0.6; 
            }

            createMesh(position) {
                const geometry = new THREE.DodecahedronGeometry(0.5, 0); 
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4444FF, 
                    emissive: 0x000000, 
                    shininess: 100, 
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                scene.add(mesh);
                return mesh;
            }

            interact(delta) {
                // 1. åŸºæœ¬ä»£è¬èˆ‡è¡°æ¸›
                const baseDecay = 0.005 / evolutionStage;
                const decayRate = this.isPredator && evolutionStage === 4 ? baseDecay * 2 : baseDecay;
                
                if (evolutionStage === 1 && !expansionStarted) {
                     this.health = 1.0; 
                } else {
                    this.health -= decayRate * delta;
                }
                
                // 2. éš¨æ©Ÿç›®æ¨™ (éšæ®µä¸€ï¼Œæˆ–æ²’æœ‰é„°å±…æ™‚çš„å¾Œå‚™)
                if (evolutionStage <= 1 || (Math.random() < 0.01 && this.target.distanceTo(this.mesh.position) < 1)) {
                    this.target.set(
                       (Math.random() - 0.5) * 35,
                       (Math.random() - 0.5) * 35,
                       (Math.random() - 0.5) * 35
                   );
                }

                // 3. **ASAL ç¾¤é«”äº¤äº’é‚è¼¯ (éšæ®µ 2 å•Ÿå‹•)**
                if (evolutionStage >= 2 && lifeForms.length > 1) {
                    this.applyBoidsRules();
                }

                // 4. éšæ®µ 4 æ é£Ÿè¡Œç‚º (æª¢æŸ¥ç¢°æ’)
                if (evolutionStage === 4 && this.isPredator) {
                    const preyIndex = lifeForms.findIndex(l => 
                        !l.isPredator && l !== this && this.mesh.position.distanceTo(l.mesh.position) < 1.5
                    );
                    if (preyIndex !== -1) {
                        const prey = lifeForms[preyIndex];
                        this.health = Math.min(1.0, this.health + 0.5); 
                        prey.die();
                    }
                }
            }

            // å¯¦ä½œ Boids (ç¾¤èš) è¦å‰‡
            applyBoidsRules() {
                const neighbors = lifeForms.filter(l => 
                    l !== this && this.mesh.position.distanceTo(l.mesh.position) < 8 // 8å€‹å–®ä½å…§è¦–ç‚ºé„°å±…
                );

                if (neighbors.length === 0) return;
                
                let separation = new THREE.Vector3();
                let alignment = new THREE.Vector3();
                let cohesion = new THREE.Vector3();
                
                neighbors.forEach(neighbor => {
                    const distance = this.mesh.position.distanceTo(neighbor.mesh.position);
                    
                    // åˆ†é›¢ (é¿å…æ“æ“ )
                    if (distance < 2) {
                        separation.sub(neighbor.mesh.position.clone().sub(this.mesh.position).normalize().divideScalar(distance * distance));
                    }
                    
                    // å‡èš (èšé›†åˆ°é„°å±…ä¸­å¿ƒ)
                    cohesion.add(neighbor.mesh.position);

                    // å°é½Š/ç«¶çˆ­ (éšæ®µ 4ï¼šè¿½é€èˆ‡é€ƒè·‘)
                    if (evolutionStage === 4) {
                        if (this.isPredator && !neighbor.isPredator) {
                            // æ é£Ÿè€…è¢«è¢«æ é£Ÿè€…å¸å¼• (è¦“é£Ÿ)
                            alignment.add(neighbor.mesh.position.clone().sub(this.mesh.position).multiplyScalar(0.5));
                        } else if (!this.isPredator && neighbor.isPredator) {
                            // è¢«æ é£Ÿè€…è¢«æ é£Ÿè€…æ’æ–¥ (é€ƒè·‘)
                            separation.sub(neighbor.mesh.position.clone().sub(this.mesh.position).multiplyScalar(3));
                        }
                    } else if (evolutionStage === 3) {
                         // éšæ®µ 3ï¼šæ™¶æ ¼æ¨¹ï¼Œå‚¾å‘æ–¼èšé›†
                         cohesion.add(neighbor.mesh.position.clone().multiplyScalar(0.5));
                    }
                });
                
                // è¨ˆç®— Boids è¦å‰‡å¸¶ä¾†çš„ç›®æ¨™æ”¹è®Š
                cohesion.divideScalar(neighbors.length).sub(this.mesh.position).multiplyScalar(0.005);
                alignment.divideScalar(neighbors.length).sub(this.mesh.position).multiplyScalar(0.01);
                
                // å°‡é€™äº›åŠ›æ‡‰ç”¨æ–¼ç•¶å‰ç›®æ¨™ä½ç½®
                this.target.add(separation.multiplyScalar(0.1));
                this.target.add(cohesion.multiplyScalar(0.1));
                this.target.add(alignment.multiplyScalar(0.1));

                // é™åˆ¶ç›®æ¨™ç¯„åœ
                this.target.clampScalar(-30, 30);
            }


            update(delta) {
                this.age += delta;
                this.interact(delta);
                
                // éšæ®µä¸€éœæ­¢æœŸï¼Œä¸ç§»å‹•
                if (evolutionStage === 1 && !expansionStarted) {
                    // ä¿æŒéœæ­¢
                } else {
                    this.mesh.position.lerp(this.target, 0.015); // ç§»å‹•é€Ÿåº¦å¾®å¢
                }
                
                if (this.health <= 0) {
                    this.die();
                    return;
                }
                this.evolveAppearance();
            }
            
            // ASAL è¦–è¦ºå¢å¼·ï¼šç™¼å…‰å‹•æ…‹
            evolveAppearance() {
                const material = this.mesh.material;
                
                // **ASAL è¦–è¦ºå¢å¼·ï¼šç™¼å…‰å‹•æ…‹**
                material.emissiveIntensity = 1 + Math.sin(this.age * 5) * 0.5 * this.health;
                
                if (evolutionStage === 1) {
                    this.type = 'Silane';
                    material.color.setHex(0x4444FF); 
                    material.opacity = 0.4 + this.health * 0.6; 
                    const state = expansionStarted ? 'é€²è¡ŒåŒ–å­¸æ“´å¼µ...' : `éœæ­¢æœŸ (${Math.max(0, INITIAL_HOLD_TIME - clock.getElapsedTime()).toFixed(1)}s)`;
                    stageTitleElement.innerHTML = `<span style="color:#4444FF;">ç•¶å‰éšæ®µ: 1. ğŸ§ª åŸçŸ½å›Šèˆ‡çŸ½çƒ·åˆæˆ (${state})</span>`;
                } else if (evolutionStage === 2) {
                    this.type = 'Siloxane';
                    material.color.setHex(0xFF4500); 
                    material.emissive.setHex(0xAA00AA); 
                    material.shininess = 300; 
                    material.opacity = 1.0; 
                    if (!(this.mesh.geometry instanceof THREE.BoxGeometry)) {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    }
                    stageTitleElement.innerHTML = `<span style="color:#FF4500;">ç•¶å‰éšæ®µ: 2. ğŸ’¡ è¼»å°„çŸ½èŒ (ç¾¤é«”æ¹§ç¾å•Ÿå‹•)</span>`;
                } else if (evolutionStage === 3) {
                    this.type = 'Borosilicate';
                    material.color.setHex(0x00FFC0); 
                    material.emissive.setHex(0x004040); 
                    material.shininess = 1000; 
                    if (!(this.mesh.geometry instanceof THREE.CylinderGeometry)) {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = new THREE.CylinderGeometry(0.5, 0.8, 2, 8); 
                    }
                    stageTitleElement.innerHTML = `<span style="color:#00FFC0;">ç•¶å‰éšæ®µ: 3. ğŸ¦  å¤šç´°èƒåŒ–èˆ‡æ™¶æ ¼æ¨¹ (çµæ§‹èšåˆ)</span>`;
                } else if (evolutionStage === 4) {
                    this.type = 'Phage';
                    material.color.setHex(this.isPredator ? 0x8A2BE2 : 0x00FF00); 
                    material.emissive.setHex(this.isPredator ? 0x800080 : 0x000000); 
                    this.mesh.scale.set(this.isPredator ? 1.0 : 0.8, this.isPredator ? 1.0 : 0.8, this.isPredator ? 1.0 : 0.8);
                    stageTitleElement.innerHTML = `<span style="color:#8A2BE2;">ç•¶å‰éšæ®µ: 4. ğŸš€ çŸ½åŸºç”Ÿå‘½å¤§çˆ†ç™¼ (ç«¶çˆ­/æ é£Ÿ)</span>`;
                }
            }
            
            reproduce() {
                const newGenes = Math.max(0.01, Math.min(0.99, this.genes + (Math.random() - 0.5) * 0.1)); 
                let newPosition;

                if (evolutionStage === 3) {
                    // **éšæ®µä¸‰ï¼šæ™¶æ ¼æ¨¹èšåˆ**
                    newPosition = this.mesh.position.clone().add(
                        new THREE.Vector3((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5)
                    );
                } else {
                    newPosition = this.mesh.position.clone().add(
                        new THREE.Vector3((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4)
                    );
                }

                const newLife = new SiliconLife(lifeForms.length, newPosition, newGenes);
                newLife.health = 0.5; 
                return newLife;
            }

            die() {
                this.mesh.material.color.setHex(0x555555);
                this.mesh.scale.set(0.1, 0.1, 0.1);
                this.health = -100; 
            }
        }


        // --- æ ¸å¿ƒåˆå§‹åŒ–å‡½å¼ ---
        function init() {
            stageTitleElement = document.getElementById('stage-title');
            lifeCountValueElement = document.getElementById('life-count-value');
            elapsedTimeValueElement = document.getElementById('elapsed-time-value');
            energyLevelValueElement = document.getElementById('energy-level-value');
            siPRatioValueElement = document.getElementById('si-p-ratio-value');
            chemicalFormulaElement = document.getElementById('chemical-formula');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            light = new THREE.PointLight(0xFF4500, 2, 100); 
            light.position.set(0, 10, 0);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            clock = new THREE.Clock();

            for (let i = 0; i < 30; i++) {
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                lifeForms.push(new SiliconLife(i, position));
            }
            
            displayChemicalFormula(1);

            animate();
        }
        
        // é¡¯ç¤ºåŒ–å­¸å¼
        function displayChemicalFormula(stage) {
            if (stage === 1) {
                chemicalFormulaElement.innerHTML = 
                    `**éšæ®µä¸€åŒ–å­¸å¼ (çŸ½çƒ·åˆæˆ):**<br>
                    nSiOâ‚‚ + 2nCHâ‚„ + 2nHâ‚‚ â†’ Siâ‚™Hâ‚‚â‚™â‚Šâ‚‚ (æ¶²æ…‹çŸ½çƒ·) + 2nCOâ‚‚<br>
                    *å‚¬åŒ–åŠ‘: Fe/Ni ç¤¦ç‰©æ™¶æ ¼*`;
            } else {
                chemicalFormulaElement.innerHTML = '';
            }
        }

        // --- æ¼”åŒ–é‚è¼¯æ§åˆ¶ ---
        function checkEvolution() {
            const elapsed = clock.getElapsedTime();
            
            // éšæ®µä¸€çš„ç‰¹æ®Šè™•ç† (éœæ­¢ -> æ“´å¼µ -> ç­‰å¾… -> éšæ®µäºŒ)
            if (evolutionStage === 1) {
                if (elapsed >= INITIAL_HOLD_TIME && !expansionStarted) {
                    expansionStarted = true;
                    isExpanding = true;
                }
                
                // æ“´å¼µæœŸï¼Œé”åˆ°ä¸€å®šæ•¸é‡å¾Œåœæ­¢æ“´å¼µï¼Œé€²å…¥ç­‰å¾…æœŸ
                if (isExpanding && lifeForms.length >= MAX_LIFE_FORMS / 5) {
                    isExpanding = false; 
                }

                // åªæœ‰ç•¶æ“´å¼µå®Œæˆï¼Œä¸”ç¶“éäº†è¶³å¤ çš„éšæ®µæ™‚é–“ï¼Œæ‰é€²å…¥éšæ®µäºŒ
                if (!isExpanding && elapsed >= INITIAL_HOLD_TIME + STAGE_DURATION) {
                    evolutionStage = 2;
                    triggerStageEvent(2);
                    displayChemicalFormula(2); 
                }
            } else {
                 // éšæ®µäºŒã€ä¸‰ã€å››çš„æ¨™æº–è·³è½‰
                const newStage = Math.floor((elapsed - INITIAL_HOLD_TIME - STAGE_DURATION) / STAGE_DURATION) + 2;
                if (newStage > evolutionStage && newStage <= 4) {
                    evolutionStage = newStage;
                    triggerStageEvent(evolutionStage);
                    displayChemicalFormula(evolutionStage);
                }
            }
        }

        // éšæ®µæ€§ç’°å¢ƒå’Œç”Ÿå‘½è¦å‰‡è®ŠåŒ–
        function triggerStageEvent(stage) {
            if (stage === 2) {
                scene.background.setHex(0x1a052b); // è¼»å°„å ´åŸŸ
                environmentEnergy = 0.8; 
                siPRatio = 0.5; 
            } else if (stage === 3) {
                scene.background.setHex(0x202020); 
                // æ“´å¼µè¤‡è£½ï¼Œä½†å› ç‚ºæœ‰æ–°çš„ç¾¤èšé‚è¼¯ï¼Œçœ‹èµ·ä¾†æœƒæ›´æœ‰åº
                for (let i = 0; i < 80; i++) { 
                    const newLife = lifeForms.length > 0 ? lifeForms[Math.floor(Math.random() * lifeForms.length)].reproduce() : null;
                    if (newLife && lifeForms.length < MAX_LIFE_FORMS) {
                        lifeForms.push(newLife);
                    }
                }
                environmentEnergy = 0.5;
                siPRatio = 0.8;
            } else if (stage === 4) {
                scene.background.setHex(0x103010);
                environmentEnergy = 0.3;
                siPRatio = 1.0;
            }
        }

        // --- GUI æ›´æ–°å‡½å¼ ---
        function updateGUI() {
            const elapsed = clock.getElapsedTime();
            
            lifeCountValueElement.textContent = lifeForms.length;
            elapsedTimeValueElement.textContent = elapsed.toFixed(2) + " ç§’";
            
            let energyText;
            if (environmentEnergy < 0.4) {
                energyText = 'ä½ (ç«¶çˆ­æ¿€çƒˆ)';
            } else if (environmentEnergy < 0.7) {
                energyText = 'ä¸­ (ç©©å®š)';
            } else {
                energyText = 'é«˜ (è±å¯Œ)';
            }
            energyLevelValueElement.textContent = energyText;
            siPRatioValueElement.textContent = siPRatio.toFixed(1) + (siPRatio > 0.8 ? ' (é«˜åº¦è¤‡é›œ)' : '');
        }

        // --- æ¸²æŸ“/å‹•ç•«è¿´åœˆ ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            checkEvolution();

            let newLifeForms = [];
            lifeForms.forEach(life => {
                life.update(delta);
                
                if (life.health > -100) {
                    newLifeForms.push(life);
                    
                    let reproductionChance = 0;
                    if (evolutionStage === 1 && isExpanding) {
                        reproductionChance = 0.05; 
                    } else if (evolutionStage > 1) {
                        const baseReproductionChance = 0.001;
                        reproductionChance = baseReproductionChance * evolutionStage; 
                    }
                    
                    if (Math.random() < reproductionChance && lifeForms.length < MAX_LIFE_FORMS) {
                        newLifeForms.push(life.reproduce());
                    }
                } else {
                    scene.remove(life.mesh);
                }
            });

            lifeForms = newLifeForms.filter(life => life.health > -100); 
            
            updateGUI();

            camera.position.x = 50 * Math.cos(clock.getElapsedTime() * 0.03);
            camera.position.z = 50 * Math.sin(clock.getElapsedTime() * 0.03);
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // è¦–çª—èª¿æ•´å¤§å°è™•ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>