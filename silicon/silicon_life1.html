```
##ğŸ’» çŸ½åŸºç”Ÿå‘½æ¼”åŒ–æ¨¡æ“¬ï¼š`si_life.html`ã€‚

```html
<!DOCTYPE html>
<html>
<head>
    <title>çŸ½åŸºç”Ÿå‘½æ¼”åŒ–æ¨¡æ“¬ - Three.js å–®æª”æ¡ˆç‰ˆ</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #0a0a0a; color: white; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        #stage-title {
            font-weight: bold;
            color: #4CAF50; /* ç¶ è‰²ï¼Œçªå‡ºé¡¯ç¤º */
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="stage-title">ç•¶å‰éšæ®µ: æº–å‚™å•Ÿå‹•</div>
        <div id="life-count">ç”Ÿå‘½é«”æ•¸é‡: 0</div>
        <div id="elapsed-time">é‹è¡Œæ™‚é–“: 0.00 ç§’</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // **********************************************
        // Three.js çŸ½åŸºç”Ÿå‘½æ¼”åŒ–æ¨¡æ“¬æ ¸å¿ƒè…³æœ¬ (si_life.html)
        // **********************************************

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer, clock;
        let lifeForms = []; // å­˜å„²æ‰€æœ‰çŸ½åŸºç”Ÿå‘½ç²’å­
        let evolutionStage = 1; // ç•¶å‰æ¼”åŒ–éšæ®µ
        const STAGE_DURATION = 25; // æ¯å€‹éšæ®µæŒçºŒæ™‚é–“ (ç§’)
        const MAX_LIFE_FORMS = 500; // æœ€å¤§ç”Ÿå‘½é«”æ•¸é‡é™åˆ¶

        // --- DOM å…ƒç´  ---
        const stageTitleElement = document.getElementById('stage-title');
        const lifeCountElement = document.getElementById('life-count');
        const elapsedTimeElement = document.getElementById('elapsed-time');

        // --- çŸ½åŸºç”Ÿå‘½ç²’å­é¡åˆ¥ ---
        class SiliconLife {
            constructor(id, position) {
                this.id = id;
                this.mesh = this.createMesh(position);
                this.age = 0; // å¹´é½¡
                this.health = 1.0; // å¥åº·åº¦/ç©©å®šæ€§
                this.type = 'Silane'; // éª¨æ¶é¡å‹
                this.genes = Math.random(); // åŸºå›  (å½±éŸ¿é¡è‰²/è¡Œç‚º)
                this.target = new THREE.Vector3().copy(position); // ç§»å‹•ç›®æ¨™
            }

            // å‰µå»ºç”Ÿå‘½çš„å¯è¦–åŒ–ç¶²æ ¼ (Mesh)
            createMesh(position) {
                // åˆå§‹å½¢æ…‹: çŸ½çƒ·ï¼ˆA1ï¼‰- ç°¡å–®çš„åäºŒé¢é«”ä»£è¡¨æ™¶é«”çµæ§‹
                const geometry = new THREE.DodecahedronGeometry(0.5, 0); 
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4444FF, // åˆå§‹è—è‰²ï¼ˆä½æº«ï¼‰
                    emissive: 0x000000,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                scene.add(mesh);
                return mesh;
            }

            // ç²’å­è¡Œç‚ºå’Œä»£è¬æ¨¡æ“¬
            update(delta) {
                this.age += delta;
                
                // 1. è¡Œç‚ºï¼šç·©æ…¢ç§»å‹•åˆ°ç›®æ¨™ä½ç½®
                this.mesh.position.lerp(this.target, 0.01); 
                
                // 2. ä»£è¬èˆ‡ç©©å®šæ€§ï¼šå¥åº·åº¦è¡°æ¸› (éšæ®µè¶Šé«˜ï¼Œè¡°æ¸›è¶Šæ…¢)
                const decayRate = 0.005 / evolutionStage;
                this.health -= decayRate * delta;
                
                if (this.health <= 0) {
                    this.die();
                    return;
                }

                // 3. é¡è‰²/å½¢æ…‹é€²åŒ–
                this.evolveAppearance();
            }
            
            // æ¼”åŒ–å¤–è§€ï¼ˆæ ¹æ“šç•¶å‰éšæ®µå’Œé¡å‹ï¼‰
            evolveAppearance() {
                const material = this.mesh.material;
                
                if (evolutionStage === 1) {
                    // éšæ®µä¸€ï¼šåŸçŸ½å›Š (Silane) - ä½ç©©å®šæ€§ï¼Œæ²¹ç‹€
                    material.color.setHex(0x4444FF); 
                    material.opacity = 0.4 + this.health * 0.6; // é€æ˜åº¦è®ŠåŒ–
                    stageTitleElement.innerHTML = `ç•¶å‰éšæ®µ: 1. ğŸ§ª åŸçŸ½å›Šèˆ‡çŸ½çƒ·åˆæˆ`;
                } else if (evolutionStage === 2) {
                    // éšæ®µäºŒï¼šè¼»å°„çŸ½èŒ (Siloxanes) - é«˜æº«ç©©å®šï¼Œé¡è‰²è®Šç´…
                    this.type = 'Siloxane';
                    material.color.setHex(0xFF4500); // æ©™ç´…è‰²ï¼ˆé«˜æº«ç†±æ¶²ç’°å¢ƒï¼‰
                    material.shininess = 200; 
                    material.opacity = 1.0; // ç©©å®šåŒ–
                    stageTitleElement.innerHTML = `ç•¶å‰éšæ®µ: 2. ğŸ’¡ è¼»å°„è‡ªç‡Ÿèˆ‡éºå‚³ç¢ºç«‹`;

                    // å½¢æ…‹è®ŠåŒ–ï¼šå¾çƒé«”è®Šç‚ºå¤šé¢é«”/ç«‹æ–¹é«”
                    if (!(this.mesh.geometry instanceof THREE.BoxGeometry)) {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    }
                } else if (evolutionStage === 3) {
                     // éšæ®µä¸‰ï¼šæ™¶æ ¼æ¨¹ (Borosilicates) - çµæ§‹è¤‡é›œ
                    this.type = 'Borosilicate';
                    material.color.setHex(0x00FFC0); // é’è‰²/ç¤¦ç‰©è‰²
                    
                    // å½¢æ…‹è®ŠåŒ–ï¼šæŸ±ç‹€ï¼ˆæ¨¹å¹¹/æ™¶æ ¼ï¼‰
                    if (!(this.mesh.geometry instanceof THREE.CylinderGeometry)) {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = new THREE.CylinderGeometry(0.5, 0.8, 2, 8); 
                    }
                     stageTitleElement.innerHTML = `ç•¶å‰éšæ®µ: 3. ğŸ¦  å¤šç´°èƒåŒ–èˆ‡æ™¶æ ¼æ¨¹`;
                } else if (evolutionStage === 4) {
                    // éšæ®µå››ï¼šç”Ÿå‘½å¤§çˆ†ç™¼ (æ é£Ÿè€…èˆ‡è¢«æ é£Ÿè€…)
                    this.type = 'Phage';
                    // é¡è‰²æ ¹æ“šåŸºå› åˆ†åŒ–ï¼šæ¨¡æ“¬æ é£Ÿè€…èˆ‡è¢«æ é£Ÿè€…
                    material.color.setHex(this.genes > 0.6 ? 0x8A2BE2 : 0x00FF00); // ç´«è‰² vs ç¶ è‰²
                    
                    // å¤§çˆ†ç™¼å½¢æ…‹ï¼šæ›´å°çš„ã€æ›´æ´»èºçš„å€‹é«”
                    this.mesh.scale.set(0.8, 0.8, 0.8);

                    stageTitleElement.innerHTML = `ç•¶å‰éšæ®µ: 4. ğŸš€ çŸ½åŸºç”Ÿå‘½å¤§çˆ†ç™¼`;
                }
            }
            
            // ç¹æ®–ï¼ˆçªè®Šï¼‰
            reproduce() {
                // åŸºå› çªè®Š
                const newGenes = Math.max(0.01, Math.min(0.99, this.genes + (Math.random() - 0.5) * 0.1)); 
                const newPosition = this.mesh.position.clone().add(
                    new THREE.Vector3((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4)
                );
                const newLife = new SiliconLife(lifeForms.length, newPosition);
                newLife.genes = newGenes; // ç¹¼æ‰¿çªè®Šå¾Œçš„åŸºå› 
                return newLife;
            }

            // æ­»äº¡ä¸¦åˆ†è§£
            die() {
                this.mesh.material.color.setHex(0x555555);
                this.mesh.scale.set(0.1, 0.1, 0.1);
                this.health = -100; // æ¨™è¨˜ç‚ºæ­»äº¡
            }
        }


        // --- æ ¸å¿ƒåˆå§‹åŒ–å‡½å¼ ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // ç‡ˆå…‰è¨­ç½®
            const light = new THREE.PointLight(0xFF4500, 2, 100); 
            light.position.set(0, 10, 0);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            clock = new THREE.Clock();

            // åˆå§‹ç”Ÿæˆå°‘é‡ç”Ÿå‘½å‹å¼ (éšæ®µä¸€ï¼šåŸçŸ½å›Š)
            for (let i = 0; i < 30; i++) {
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                lifeForms.push(new SiliconLife(i, position));
            }

            animate();
        }

        // --- æ¼”åŒ–é‚è¼¯æ§åˆ¶ ---
        function checkEvolution() {
            const elapsed = clock.getElapsedTime();
            // æ¯ STAGE_DURATION ç§’é€²å…¥ä¸‹ä¸€éšæ®µ
            const newStage = Math.floor(elapsed / STAGE_DURATION) + 1;
            
            if (newStage > evolutionStage && newStage <= 4) {
                evolutionStage = newStage;
                console.log(`--- é€²å…¥æ¼”åŒ–éšæ®µ ${evolutionStage} ---`);
                triggerStageEvent(evolutionStage);
            }
        }

        // éšæ®µæ€§ç’°å¢ƒå’Œç”Ÿå‘½è¦å‰‡è®ŠåŒ–
        function triggerStageEvent(stage) {
            if (stage === 2) {
                // éšæ®µäºŒï¼šè¼»å°„è‡ªç‡Ÿç¢ºç«‹ (èƒŒæ™¯è®Šç´«/è¼»å°„è‰²)
                scene.background.setHex(0x1a052b); 
                // æé«˜ç’°å¢ƒå…‰å¼·åº¦
                scene.traverse(obj => {
                    if (obj instanceof THREE.Mesh) {
                        obj.material.emissive.setHex(0xAA00AA); 
                    }
                });
            } else if (stage === 3) {
                // éšæ®µä¸‰ï¼šå¤šç´°èƒåŒ–èˆ‡æ™¶æ ¼æ¨¹ (å¤§é‡ç¹æ®–æ“´å¼µ)
                scene.background.setHex(0x202020); 
                for (let i = 0; i < 80; i++) { // é¡å¤–ç¹æ®– 80 å€‹
                    const newLife = lifeForms.length > 0 ? lifeForms[Math.floor(Math.random() * lifeForms.length)].reproduce() : null;
                    if (newLife && lifeForms.length < MAX_LIFE_FORMS) {
                        lifeForms.push(newLife);
                    }
                }
            } else if (stage === 4) {
                // éšæ®µå››ï¼šç”Ÿå‘½å¤§çˆ†ç™¼ (ç«¶çˆ­æ¿€çƒˆ)
                scene.background.setHex(0x103010); // åœ°è¡¨ç”Ÿæ…‹
                // åœ¨æ­¤è™•å¯åŠ å…¥æ›´è¤‡é›œçš„ç«¶çˆ­å’Œæ·˜æ±°é‚è¼¯
            }
        }

        // --- æ¸²æŸ“/å‹•ç•«è¿´åœˆ ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            checkEvolution();

            // æ›´æ–°ç”Ÿå‘½é«”ç‹€æ…‹
            let newLifeForms = [];
            lifeForms.forEach(life => {
                life.update(delta);
                
                if (life.health > 0) {
                    newLifeForms.push(life);
                    
                    // éš¨æ©Ÿç¹æ®–ï¼ˆæ©Ÿç‡éš¨éšæ®µæé«˜ï¼‰
                    const baseReproductionChance = 0.001;
                    const reproductionChance = baseReproductionChance * evolutionStage; // éšæ®µè¶Šé«˜ï¼Œç¹æ®–è¶Šå¿«
                    
                    if (Math.random() < reproductionChance && lifeForms.length < MAX_LIFE_FORMS) {
                        newLifeForms.push(life.reproduce());
                    }

                    // éš¨æ©Ÿç§»å‹•ç›®æ¨™
                    if (Math.random() < 0.05) {
                         life.target.set(
                            (Math.random() - 0.5) * 35,
                            (Math.random() - 0.5) * 35,
                            (Math.random() - 0.5) * 35
                        );
                    }
                } else if (life.health === -100) {
                    // ç§»é™¤å·²æ­»äº¡çš„ç²’å­
                    scene.remove(life.mesh);
                }
            });

            lifeForms = newLifeForms.filter(life => life.health > -100); // éæ¿¾æ‰å·²ç¶“æ­»äº¡çš„
            
            // æ›´æ–°è³‡è¨Šé¢æ¿
            lifeCountElement.innerHTML = `ç”Ÿå‘½é«”æ•¸é‡: ${lifeForms.length}`;
            elapsedTimeElement.innerHTML = `é‹è¡Œæ™‚é–“: ${elapsed.toFixed(2)} ç§’`;


            // é¡é ­ç·©æ…¢æ—‹è½‰
            camera.position.x = 50 * Math.cos(elapsed * 0.03);
            camera.position.z = 50 * Math.sin(elapsed * 0.03);
            camera.lookAt(scene.position);


            renderer.render(scene, camera);
        }

        // è¦–çª—èª¿æ•´å¤§å°è™•ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // å•Ÿå‹•æ¨¡æ“¬
        init();
    </script>
</body>
</html>
