<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neural Network Diagram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1 {
            color: white;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: clamp(16px, 5vw, 24px);
            text-align: center;
        }
        
        .canvas-container {
            width: 100%;
            max-width: 1200px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            touch-action: none;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: pointer;
        }
        
        .controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            padding: 0 10px;
        }
        
        button {
            padding: 15px 20px;
            font-size: clamp(14px, 3.5vw, 16px);
            background: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 600;
            touch-action: manipulation;
        }
        
        button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .info {
            color: white;
            margin-top: 15px;
            text-align: center;
            font-size: clamp(12px, 3vw, 14px);
            opacity: 0.9;
            padding: 0 20px;
            line-height: 1.5;
        }
        
        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            
            h1 {
                margin-bottom: 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 12px 16px;
            }
        }
    </style>
</head>
<body>
    <h1>人工神經網絡圖</h1>
    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="controls">
        <button onclick="animateSignal()">發送信號</button>
        <button onclick="continuousAnimation()">連續模式</button>
        <button onclick="stopAnimation()">停止</button>
        <button onclick="resetHighlight()">重置</button>
    </div>
    <div class="info">點擊畫布或"發送信號"查看數據流動</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let scale = 1;
        let layers, neuronRadius, layerHeight;
        
        function initCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = Math.min(width * 0.5, window.innerHeight * 0.6);
            
            canvas.width = width;
            canvas.height = height;
            
            scale = width / 1200;
            neuronRadius = 18 * scale;
            layerHeight = height * 0.83;
            
            layers = [
                { name: 'Input', x: width * 0.08, neurons: 9 },
                { name: 'Node 1', x: width * 0.29, neurons: 9 },
                { name: 'Node 2', x: width * 0.50, neurons: 9 },
                { name: 'Node 3', x: width * 0.71, neurons: 9 },
                { name: 'Output', x: width * 0.92, neurons: 4 }
            ];
        }
        
        let animating = false;
        let continuousMode = false;
        let activeConnections = new Map();
        let activationLevel = new Map();
        
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', 
            '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
            '#F8B739'
        ];
        
        function getNeuronY(layerIndex, neuronIndex) {
            const layer = layers[layerIndex];
            const spacing = layerHeight / (layer.neurons + 1);
            return canvas.height * 0.08 + spacing * (neuronIndex + 1);
        }
        
        function getConnectionKey(fromLayer, fromNeuron, toLayer, toNeuron) {
            return `${fromLayer}-${fromNeuron}-${toLayer}-${toNeuron}`;
        }
        
        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製連接線
            for (let i = 0; i < layers.length - 1; i++) {
                for (let j = 0; j < layers[i].neurons; j++) {
                    for (let k = 0; k < layers[i + 1].neurons; k++) {
                        const x1 = layers[i].x;
                        const y1 = getNeuronY(i, j);
                        const x2 = layers[i + 1].x;
                        const y2 = getNeuronY(i + 1, k);
                        
                        const key = getConnectionKey(i, j, i + 1, k);
                        const activation = activeConnections.get(key) || 0;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        
                        if (activation > 0) {
                            const colorIndex = (j + k) % colors.length;
                            ctx.strokeStyle = colors[colorIndex];
                            ctx.lineWidth = (1.5 + activation * 1.5) * scale;
                            ctx.globalAlpha = activation;
                        } else {
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
                            ctx.lineWidth = 0.5 * scale;
                            ctx.globalAlpha = 1;
                        }
                        
                        ctx.stroke();
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            
            // 繪製神經元
            layers.forEach((layer, layerIndex) => {
                for (let i = 0; i < layer.neurons; i++) {
                    const x = layer.x;
                    const y = getNeuronY(layerIndex, i);
                    const neuronKey = `${layerIndex}-${i}`;
                    const activation = activationLevel.get(neuronKey) || 0;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    
                    if (activation > 0) {
                        const colorIndex = i % colors.length;
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, neuronRadius);
                        gradient.addColorStop(0, colors[colorIndex]);
                        gradient.addColorStop(1, '#a8c5dd');
                        ctx.fillStyle = gradient;
                        ctx.shadowBlur = 10 * activation * scale;
                        ctx.shadowColor = colors[colorIndex];
                    } else {
                        ctx.fillStyle = '#a8c5dd';
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fill();
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 1.5 * scale;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            });
            
            // 繪製層標籤
            ctx.fillStyle = '#2c3e50';
            ctx.font = `${Math.max(10, 12 * scale)}px Arial`;
            ctx.textAlign = 'center';
            layers.forEach((layer, index) => {
                ctx.fillText(layer.name, layer.x, canvas.height * 0.04);
            });
        }
        
        function animateSignal() {
            if (animating && !continuousMode) return;
            
            animating = true;
            let step = 0;
            const maxSteps = 60;
            
            function animateStep() {
                if (!animating && !continuousMode) return;
                
                const progress = step / maxSteps;
                const currentLayer = Math.floor(progress * (layers.length - 1));
                const layerProgress = (progress * (layers.length - 1)) - currentLayer;
                
                if (step === 0) {
                    activeConnections.clear();
                    activationLevel.clear();
                }
                
                if (currentLayer < layers.length) {
                    for (let i = 0; i < layers[currentLayer].neurons; i++) {
                        const neuronKey = `${currentLayer}-${i}`;
                        activationLevel.set(neuronKey, Math.max(0, 1 - layerProgress));
                    }
                }
                
                if (currentLayer + 1 < layers.length && layerProgress > 0) {
                    for (let i = 0; i < layers[currentLayer + 1].neurons; i++) {
                        const neuronKey = `${currentLayer + 1}-${i}`;
                        activationLevel.set(neuronKey, layerProgress);
                    }
                }
                
                if (currentLayer < layers.length - 1) {
                    for (let j = 0; j < layers[currentLayer].neurons; j++) {
                        for (let k = 0; k < layers[currentLayer + 1].neurons; k++) {
                            const key = getConnectionKey(currentLayer, j, currentLayer + 1, k);
                            activeConnections.set(key, Math.min(1, layerProgress * 2));
                        }
                    }
                }
                
                if (currentLayer > 0 && layerProgress > 0.5) {
                    for (let j = 0; j < layers[currentLayer - 1].neurons; j++) {
                        for (let k = 0; k < layers[currentLayer].neurons; k++) {
                            const key = getConnectionKey(currentLayer - 1, j, currentLayer, k);
                            const fadeOut = Math.max(0, 1 - (layerProgress - 0.5) * 2);
                            activeConnections.set(key, fadeOut);
                        }
                    }
                }
                
                drawNetwork();
                
                step++;
                if (step < maxSteps) {
                    requestAnimationFrame(animateStep);
                } else {
                    if (continuousMode) {
                        step = 0;
                        setTimeout(animateStep, 500);
                    } else {
                        animating = false;
                        setTimeout(resetHighlight, 2000);
                    }
                }
            }
            
            animateStep();
        }
        
        function continuousAnimation() {
            continuousMode = true;
            if (!animating) {
                animateSignal();
            }
        }
        
        function stopAnimation() {
            continuousMode = false;
            animating = false;
        }
        
        function resetHighlight() {
            stopAnimation();
            activeConnections.clear();
            activationLevel.clear();
            drawNetwork();
        }
        
        // 初始化
        initCanvas();
        drawNetwork();
        
        // 響應式調整
        window.addEventListener('resize', () => {
            initCanvas();
            drawNetwork();
        });
        
        // 觸控支持
        canvas.addEventListener('click', () => {
            if (!continuousMode && !animating) {
                animateSignal();
            }
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!continuousMode && !animating) {
                animateSignal();
            }
        });
    </script>
</body>
</html>