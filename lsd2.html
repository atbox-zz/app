<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSD & Psilocybin - å…‰ç²’å­èˆ‡ç·šæ¢ä¹‹æ—…</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(131, 56, 236, 0.3);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }
        .substance {
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #8338ec;
        }
        .substance h2 {
            margin: 0 0 8px 0;
            font-size: 18px;
            color: #ff006e;
        }
        .substance p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(131, 56, 236, 0.3);
        }
        #audioToggle {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(45deg, #ff006e, #8338ec);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.5);
        }
        #audioToggle:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.8);
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>ğŸ„ è¿·å¹»ç‰©è³ªè¦–è¦ºåŒ–</h1>
        
        <div class="substance">
            <h2>LSD (éº¥è§’é…¸äºŒä¹™èƒº)</h2>
            <p><strong>ä¾†æºï¼š</strong>éº¥è§’èŒè¡ç”Ÿçš„åŠåˆæˆåŒ–åˆç‰©</p>
            <p><strong>ä½œç”¨ï¼š</strong>5-HT2A å—é«”æ¿€å‹•åŠ‘ï¼Œæ”¹è®Šæ„ŸçŸ¥ã€æ™‚é–“æ„Ÿå’Œæ„è­˜</p>
            <p><strong>ç‰¹é»ï¼š</strong>æ¥µå¼·æ•ˆåŠ›ï¼Œ20-30å¾®å…‹å³å¯ç”¢ç”Ÿæ•ˆæœï¼ŒæŒçºŒ8-12å°æ™‚</p>
        </div>

        <div class="substance">
            <h2>Psilocybin (è£¸è“‹è‡ç´ )</h2>
            <p><strong>ä¾†æºï¼š</strong>å¤©ç„¶å­˜åœ¨æ–¼å¤šç¨®è˜‘è‡ä¸­</p>
            <p><strong>ä½œç”¨ï¼š</strong>åœ¨é«”å…§è½‰åŒ–ç‚º psilocinï¼Œä½œç”¨æ–¼è¡€æ¸…ç´ å—é«”</p>
            <p><strong>ç‰¹é»ï¼š</strong>æŒçºŒ4-6å°æ™‚ï¼Œåœ¨é†«å­¸ç ”ç©¶ä¸­ç”¨æ–¼æ²»ç™‚æŠ‘é¬±ç—‡</p>
        </div>
    </div>

    <div id="controls">
        <button id="audioToggle">ğŸµ å•Ÿå‹•éŸ³æ¨‚é«”é©—</button>
        <p style="margin:0;">ğŸ¨ æ‹–å‹•æ»‘é¼ æ—‹è½‰è¦–è§’ | æ»¾è¼ªç¸®æ”¾</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        let scene, camera, renderer;
        let time = 0;
        let synth, filter, reverb, delay, chorus;
        let audioStarted = false;
        let particles = [];
        let lines = [];
        let mouseX = 0, mouseY = 0;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            initAudio();

            const audioBtn = document.getElementById('audioToggle');
            audioBtn.addEventListener('click', async () => {
                if (!audioStarted) {
                    await Tone.start();
                    startAmbientMusic();
                    audioStarted = true;
                    audioBtn.textContent = 'ğŸ”Š éŸ³æ¨‚æ’­æ”¾ä¸­';
                    audioBtn.style.background = 'linear-gradient(45deg, #06ffa5, #00d9ff)';
                } else {
                    stopAmbientMusic();
                    audioStarted = false;
                    audioBtn.textContent = 'ğŸµ å•Ÿå‹•éŸ³æ¨‚é«”é©—';
                    audioBtn.style.background = 'linear-gradient(45deg, #ff006e, #8338ec)';
                }
            });

            createParticleSystem();
            createFlowingLines();
            createEnergyRings();

            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            document.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.02;
                camera.position.z = Math.max(10, Math.min(50, camera.position.z));
            });

            window.addEventListener('resize', onWindowResize);
        }

        function createParticleSystem() {
            // å‰µå»ºå¤šçµ„å…‰ç²’å­ç³»çµ±
            for (let sys = 0; sys < 5; sys++) {
                const particleCount = 300;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const velocities = [];

                const hue = sys / 5;

                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20 + sys * 5;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = Math.sin(angle) * radius;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 30;

                    const color = new THREE.Color().setHSL(hue, 1, 0.6);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;

                    sizes[i] = Math.random() * 0.5 + 0.2;

                    velocities.push({
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    });
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const particleSystem = new THREE.Points(geometry, material);
                particleSystem.userData = { velocities, hue };
                scene.add(particleSystem);
                particles.push(particleSystem);
            }
        }

        function createFlowingLines() {
            // å‰µå»ºæµå‹•çš„èƒ½é‡ç·š
            for (let i = 0; i < 20; i++) {
                const points = [];
                const segments = 50;
                const radius = 15 + i * 0.5;
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    const z = Math.sin(angle * 3 + i) * 5;
                    points.push(new THREE.Vector3(x, y, z));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const color = new THREE.Color().setHSL(i / 20, 1, 0.5);
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });

                const line = new THREE.Line(geometry, material);
                line.userData = { baseRadius: radius, offset: i };
                scene.add(line);
                lines.push(line);
            }
        }

        function createEnergyRings() {
            // å‰µå»ºè„ˆå‹•èƒ½é‡ç’°
            for (let i = 0; i < 8; i++) {
                const geometry = new THREE.RingGeometry(8 + i * 2, 8.5 + i * 2, 64);
                const color = new THREE.Color().setHSL(i / 8, 1, 0.5);
                
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });

                const ring = new THREE.Mesh(geometry, material);
                ring.rotation.x = Math.PI / 2;
                ring.userData = { phase: i, baseScale: 1 };
                scene.add(ring);
                lines.push(ring);
            }
        }

        function initAudio() {
            reverb = new Tone.Reverb({
                decay: 8,
                wet: 0.4
            }).toDestination();

            delay = new Tone.FeedbackDelay({
                delayTime: '8n',
                feedback: 0.3,
                wet: 0.2
            }).connect(reverb);

            filter = new Tone.Filter({
                frequency: 800,
                type: 'lowpass',
                rolloff: -24
            }).connect(delay);

            chorus = new Tone.Chorus({
                frequency: 0.5,
                delayTime: 3.5,
                depth: 0.7,
                wet: 0.3
            }).connect(filter);

            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 2,
                    decay: 1,
                    sustain: 0.7,
                    release: 4
                }
            }).connect(chorus);
        }

        let ambientLoop, bassLoop, melodyLoop;

        function startAmbientMusic() {
            const chordProgression = [
                ['C3', 'E3', 'G3', 'B3'],
                ['A2', 'C3', 'E3', 'G3'],
                ['F2', 'A2', 'C3', 'E3'],
                ['G2', 'B2', 'D3', 'F3']
            ];

            let chordIndex = 0;

            ambientLoop = new Tone.Loop((time) => {
                synth.triggerAttackRelease(chordProgression[chordIndex], '2n', time);
                chordIndex = (chordIndex + 1) % chordProgression.length;
            }, '2n');

            const bass = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 0.1,
                    decay: 0.3,
                    sustain: 0.4,
                    release: 1
                }
            }).connect(filter);

            bassLoop = new Tone.Loop((time) => {
                const notes = ['C2', 'A1', 'F1', 'G1'];
                bass.triggerAttackRelease(notes[chordIndex], '4n', time);
            }, '1n');

            const lead = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: {
                    attack: 0.5,
                    decay: 0.2,
                    sustain: 0.3,
                    release: 2
                }
            }).connect(chorus);

            const melodyNotes = ['E4', 'G4', 'A4', 'B4', 'C5', 'B4', 'A4', 'G4'];
            let melodyIndex = 0;

            melodyLoop = new Tone.Loop((time) => {
                if (Math.random() > 0.3) {
                    lead.triggerAttackRelease(melodyNotes[melodyIndex], '8n', time);
                }
                melodyIndex = (melodyIndex + 1) % melodyNotes.length;
            }, '8n');

            Tone.Transport.bpm.value = 60;
            ambientLoop.start(0);
            bassLoop.start(0);
            melodyLoop.start(0);
            Tone.Transport.start();
        }

        function stopAmbientMusic() {
            if (ambientLoop) ambientLoop.stop();
            if (bassLoop) bassLoop.stop();
            if (melodyLoop) melodyLoop.stop();
            Tone.Transport.stop();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // æ›´æ–°ç²’å­ç³»çµ±
            particles.forEach((system, idx) => {
                const positions = system.geometry.attributes.position.array;
                const colors = system.geometry.attributes.color.array;
                const velocities = system.userData.velocities;
                const hue = system.userData.hue;

                for (let i = 0; i < positions.length / 3; i++) {
                    // èºæ—‹é‹å‹•
                    const angle = time * 0.5 + i * 0.1;
                    const radius = 15 + Math.sin(time + i * 0.1) * 10;
                    
                    positions[i * 3] += velocities[i].x + Math.cos(angle) * 0.05;
                    positions[i * 3 + 1] += velocities[i].y + Math.sin(angle) * 0.05;
                    positions[i * 3 + 2] += velocities[i].z;

                    // é‚Šç•Œæª¢æŸ¥
                    if (Math.abs(positions[i * 3]) > 40) velocities[i].x *= -1;
                    if (Math.abs(positions[i * 3 + 1]) > 40) velocities[i].y *= -1;
                    if (Math.abs(positions[i * 3 + 2]) > 40) velocities[i].z *= -1;

                    // é¡è‰²è®ŠåŒ–
                    const newHue = (hue + time * 0.05 + i * 0.001) % 1;
                    const color = new THREE.Color().setHSL(newHue, 1, 0.6);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                system.geometry.attributes.position.needsUpdate = true;
                system.geometry.attributes.color.needsUpdate = true;
                system.rotation.z += 0.001;
            });

            // æ›´æ–°æµå‹•ç·šæ¢å’Œèƒ½é‡ç’°
            lines.forEach((line, i) => {
                if (line.geometry.type === 'BufferGeometry' && line.type === 'Line') {
                    // æµå‹•ç·šæ¢
                    const positions = line.geometry.attributes.position.array;
                    const offset = line.userData.offset;
                    const radius = line.userData.baseRadius;

                    for (let j = 0; j < positions.length / 3; j++) {
                        const angle = (j / (positions.length / 3)) * Math.PI * 2;
                        const wave = Math.sin(time * 2 + angle * 3 + offset) * 3;
                        positions[j * 3] = Math.cos(angle + time * 0.5) * (radius + wave);
                        positions[j * 3 + 1] = Math.sin(angle + time * 0.5) * (radius + wave);
                        positions[j * 3 + 2] = Math.sin(angle * 3 + i + time) * 5 + wave;
                    }

                    line.geometry.attributes.position.needsUpdate = true;

                    // é¡è‰²è®ŠåŒ–
                    const hue = (i / 20 + time * 0.1) % 1;
                    line.material.color.setHSL(hue, 1, 0.5);
                } else if (line.geometry.type === 'RingGeometry') {
                    // èƒ½é‡ç’°è„ˆå‹•
                    const phase = line.userData.phase;
                    const scale = 1 + Math.sin(time * 2 + phase) * 0.3;
                    line.scale.set(scale, scale, 1);
                    line.rotation.z = time * 0.3 + phase;
                    
                    const hue = (phase / 8 + time * 0.1) % 1;
                    line.material.color.setHSL(hue, 1, 0.5);
                    line.material.opacity = 0.3 + Math.sin(time * 3 + phase) * 0.2;
                }
            });

            // ç›¸æ©Ÿé‹å‹•
            camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
            camera.position.y += (mouseY * 5 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>