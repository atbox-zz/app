<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>量子DNA · 史詩螺旋</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Microsoft JhengHei', Arial, sans-serif;
      height: 100vh;
      color: white;
    }
    #container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 255, 255, 0.9);
      color: #000;
      font-size: 24px;
      font-weight: bold;
      padding: 30px 60px;
      border-radius: 15px;
      cursor: pointer;
      z-index: 100;
      border: 3px solid #fff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
      transition: transform 0.3s;
    }
    #start-btn:hover {
      transform: translate(-50%, -50%) scale(1.1);
    }
    .title {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 42px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
      z-index: 10;
    }
    .footer {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 18px;
      text-align: center;
      z-index: 10;
      opacity: 0.9;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .stats {
      position: absolute;
      top: 30px;
      left: 30px;
      color: #0ff;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      z-index: 10;
      background: rgba(0,0,0,0.8);
      padding: 15px 20px;
      border-radius: 8px;
      border: 2px solid #0ff;
      box-shadow: 0 0 20px rgba(0,255,255,0.3);
    }
    .credit {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255,255,255,0.5);
      font-size: 10px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!--div id="start-btn">🎵 點擊開始史詩之旅 🎵</div-->

  <div class="title" id="title">2<sup>0</sup> = 1</div>

  <!--div class="footer">
    無限多方向DNA螺旋網絡 · 亂中有序 · 對數爆炸成長
  </div-->

  <!--div class="stats" id="stats">
    <div style="margin-bottom:8px;font-size:16px;font-weight:bold;">等級 0 / 64</div>
    <div style="margin-bottom:5px;">理論粒子: 1</div>
    <div style="margin-bottom:5px;">顯示粒子: 1</div>
    <div style="margin-bottom:8px;font-size:16px;color:#ff0;font-weight:bold;">螺旋數量: 1</div>
    <div style="font-size:12px;opacity:0.8;font-style:italic;">混沌初開...</div>
  </div-->

  <div class="credit">
    Music: "Epic Cinematic Trailer" by Lexin Music (CC BY 4.0)
  </div>

  <!-- Load libraries from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <script>
    // DOM references
    const container = document.getElementById('container');
    //const startBtn = document.getElementById('start-btn');
    const titleEl = document.getElementById('title');
    const statsEl = document.getElementById('stats');

    // State
    let growthLevel = 0;
    let particleCount = 1;
    let activeCount = 1;
    let helixCount = 1;
    let audioStarted = false;

    // Initialize Three.js
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 30, 100);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(30, 20, 30);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Particle system
    const maxParticles = 100000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3);
    const colors = new Float32Array(maxParticles * 3);

    for (let i = 0; i < maxParticles; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 60;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 60;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
      colors[i * 3] = 0.2;
      colors[i * 3 + 1] = 0.3;
      colors[i * 3 + 2] = 0.5;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.35,
      vertexColors: true,
      transparent: true,
      opacity: 0.85,
      sizeAttenuation: true
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // Line system
    const lineGeometry = new THREE.BufferGeometry();
    const linePositions = new Float32Array(maxParticles * 12);
    const lineColors = new Float32Array(maxParticles * 12);
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));

    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending
    });

    const lineSystem = new THREE.LineSegments(lineGeometry, lineMaterial);
    scene.add(lineSystem);

    // Directions
    const directions = [
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(-1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, -1, 0),
      new THREE.Vector3(0, 0, 1),
      new THREE.Vector3(0, 0, -1),
      new THREE.Vector3(0.707, 0.707, 0),
      new THREE.Vector3(-0.707, 0.707, 0),
      new THREE.Vector3(0.707, -0.707, 0),
      new THREE.Vector3(-0.707, -0.707, 0),
      new THREE.Vector3(0.707, 0, 0.707),
      new THREE.Vector3(-0.707, 0, 0.707),
      new THREE.Vector3(0.707, 0, -0.707),
      new THREE.Vector3(-0.707, 0, -0.707),
      new THREE.Vector3(0, 0.707, 0.707),
      new THREE.Vector3(0, -0.707, 0.707),
    ];

    const getHelixCount = (level) => {
      if (level === 0) return 1;
      return Math.min(Math.pow(2, Math.floor(level / 2)), 10000);
    };

    const getDNAPosition = (index, total, level) => {
      const currentHelixCount = getHelixCount(level);
      const particlesPerHelix = Math.max(Math.floor(total / currentHelixCount), 1);
      const helixIndex = Math.floor(index / particlesPerHelix);
      const indexInHelix = index % particlesPerHelix;
      const progressInHelix = indexInHelix / Math.max(particlesPerHelix, 1);

      const directionIndex = helixIndex % directions.length;
      const baseDirection = directions[directionIndex].clone();
      const randomOffset = new THREE.Vector3(
        Math.sin(helixIndex * 2.718) * 0.3,
        Math.cos(helixIndex * 3.141) * 0.3,
        Math.sin(helixIndex * 1.618) * 0.3
      );
      const direction = baseDirection.clone().add(randomOffset).normalize();

      const turns = 8 + (level * 0.3);
      const angle = progressInHelix * Math.PI * 2 * turns;
      const length = progressInHelix * (15 + level * 0.8);
      const strand = indexInHelix % 2;
      const strandPhase = strand * Math.PI;
      const spiralRadius = 1.5 + Math.sin(progressInHelix * Math.PI * 6) * 0.4;

      const perpendicular1 = new THREE.Vector3();
      const perpendicular2 = new THREE.Vector3();
      if (Math.abs(direction.y) < 0.9) {
        perpendicular1.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
      } else {
        perpendicular1.crossVectors(direction, new THREE.Vector3(1, 0, 0)).normalize();
      }
      perpendicular2.crossVectors(direction, perpendicular1).normalize();

      const centerPos = direction.clone().multiplyScalar(length);
      const spiralOffset = perpendicular1.clone()
        .multiplyScalar(Math.cos(angle + strandPhase) * spiralRadius)
        .add(perpendicular2.clone().multiplyScalar(Math.sin(angle + strandPhase) * spiralRadius));
      const finalPos = centerPos.add(spiralOffset);

      return { pos: finalPos, helixIndex, strandIndex: strand, progressInHelix, indexInHelix };
    };

    const getColor = (helixIndex, progress) => {
      const hue = ((helixIndex * 0.618033988749895) % 1) * 0.85 + progress * 0.15;
      const saturation = 0.8 + Math.sin(progress * Math.PI * 4) * 0.15;
      const lightness = 0.5 + Math.sin(helixIndex * 1.234 + progress * Math.PI * 2) * 0.2;
      return new THREE.Color().setHSL(hue, saturation, lightness);
    };

    // Audio setup
    let audioInitialized = false;
    const initAudio = async () => {
      if (audioInitialized) return;
      audioInitialized = true;

      try {
        await Tone.start();

        const reverb = new Tone.Reverb({ decay: 5, wet: 0.35 }).toDestination();
        const player = new Tone.Player({
          url: 'https://cdn.jsdelivr.net/gh/lexin-music/epic-cinematic-trailer@main/epic-cinematic-trailer.mp3',
          loop: true,
          volume: -10
        }).connect(reverb);

        player.on('load', () => {
          player.start(0);
          audioStarted = true;
          //startBtn.style.display = 'none';
        });

        player.on('error', (err) => {
          console.error('Audio load error:', err);
          audioStarted = true;
          //startBtn.style.display = 'none';
        });
      } catch (err) {
        console.error('Tone start error:', err);
        //startBtn.style.display = 'none';
      }
    };

    //startBtn.addEventListener('click', initAudio);

    // Animation loop
    let currentLevel = 0;
    let currentActiveCount = 1;
    let lastUpdate = Date.now();
    let animationTime = 0;

    const animate = () => {
      requestAnimationFrame(animate);
      animationTime += 0.01;

      const now = Date.now();
      if (now - lastUpdate >= 1000 && currentLevel < 64) {
        currentLevel++;
        currentActiveCount = Math.min(Math.pow(2, currentLevel), maxParticles);
        const currentHelixCount = getHelixCount(currentLevel);
        lastUpdate = now;

        // Update state
        growthLevel = currentLevel;
        particleCount = Math.pow(2, currentLevel);
        activeCount = currentActiveCount;
        helixCount = currentHelixCount;

        // Update UI
        const formatNumber = (num) => {
          if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
          if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
          if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
          if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
          return num.toLocaleString();
        };

        titleEl.innerHTML = `2<sup>${growthLevel}</sup> = ${formatNumber(particleCount)}`;

        const statusText = growthLevel < 10 ? '混沌初開...' :
                          growthLevel < 20 ? '秩序漸現...' :
                          growthLevel < 30 ? '結構爆發...' :
                          growthLevel < 40 ? '網絡擴張...' :
                          growthLevel < 50 ? '指數成長...' :
                          growthLevel < 60 ? '趨向無限...' : '宇宙極限...';

        statsEl.innerHTML = `
          <div style="margin-bottom:8px;font-size:16px;font-weight:bold;">等級 ${growthLevel} / 64</div>
          <div style="margin-bottom:5px;">理論粒子: ${formatNumber(particleCount)}</div>
          <div style="margin-bottom:5px;">顯示粒子: ${activeCount.toLocaleString()}</div>
          <div style="margin-bottom:8px;font-size:16px;color:#ff0;font-weight:bold;">螺旋數量: ${helixCount.toLocaleString()}</div>
          <div style="font-size:12px;opacity:0.8;font-style:italic;">${statusText}</div>
        `;
      }

      const posArray = geometry.attributes.position.array;
      const colorArray = geometry.attributes.color.array;
      const linePos = lineGeometry.attributes.position.array;
      const lineCol = lineGeometry.attributes.color.array;

      let lineIndex = 0;
      const currentHelixCount = getHelixCount(currentLevel);
      const particlesPerHelix = Math.max(Math.floor(currentActiveCount / currentHelixCount), 1);

      for (let i = 0; i < maxParticles; i++) {
        if (i < currentActiveCount) {
          const dnaData = getDNAPosition(i, currentActiveCount, currentLevel);
          const targetPos = dnaData.pos;
          const quantum = Math.sin(animationTime * 2.5 + i * 0.08) * 0.12;

          posArray[i * 3] += (targetPos.x + quantum - posArray[i * 3]) * 0.05;
          posArray[i * 3 + 1] += (targetPos.y + quantum - posArray[i * 3 + 1]) * 0.05;
          posArray[i * 3 + 2] += (targetPos.z + quantum - posArray[i * 3 + 2]) * 0.05;

          const color = getColor(dnaData.helixIndex, dnaData.progressInHelix);
          colorArray[i * 3] += (color.r - colorArray[i * 3]) * 0.05;
          colorArray[i * 3 + 1] += (color.g - colorArray[i * 3 + 1]) * 0.05;
          colorArray[i * 3 + 2] += (color.b - colorArray[i * 3 + 2]) * 0.05;

          // Connect next in helix
          const nextInHelix = i + 1;
          if (nextInHelix < currentActiveCount && 
              Math.floor(nextInHelix / particlesPerHelix) === dnaData.helixIndex &&
              lineIndex < maxParticles * 4) {
            const nextData = getDNAPosition(nextInHelix, currentActiveCount, currentLevel);
            if (nextData.strandIndex === dnaData.strandIndex) {
              linePos.set([posArray[i*3], posArray[i*3+1], posArray[i*3+2], posArray[nextInHelix*3], posArray[nextInHelix*3+1], posArray[nextInHelix*3+2]], lineIndex * 3);
              lineCol.set([colorArray[i*3], colorArray[i*3+1], colorArray[i*3+2], colorArray[nextInHelix*3], colorArray[nextInHelix*3+1], colorArray[nextInHelix*3+2]], lineIndex * 3);
              lineIndex += 2;
            }
          }

          // Connect strands
          if (dnaData.indexInHelix % 4 === 0 && lineIndex < maxParticles * 4) {
            const pairIndex = dnaData.strandIndex === 0 ? i + 1 : i - 1;
            const pairHelixStart = dnaData.helixIndex * particlesPerHelix;
            if (pairIndex >= pairHelixStart && pairIndex < pairHelixStart + particlesPerHelix && pairIndex < currentActiveCount) {
              linePos.set([posArray[i*3], posArray[i*3+1], posArray[i*3+2], posArray[pairIndex*3], posArray[pairIndex*3+1], posArray[pairIndex*3+2]], lineIndex * 3);
              const dim = 0.6;
              lineCol.set([
                colorArray[i*3]*dim, colorArray[i*3+1]*dim, colorArray[i*3+2]*dim,
                colorArray[pairIndex*3]*dim, colorArray[pairIndex*3+1]*dim, colorArray[pairIndex*3+2]*dim
              ], lineIndex * 3);
              lineIndex += 2;
            }
          }
        } else {
          colorArray[i * 3] += (0.05 - colorArray[i * 3]) * 0.02;
          colorArray[i * 3 + 1] += (0.05 - colorArray[i * 3 + 1]) * 0.02;
          colorArray[i * 3 + 2] += (0.1 - colorArray[i * 3 + 2]) * 0.02;
        }
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;
      lineGeometry.attributes.position.needsUpdate = true;
      lineGeometry.attributes.color.needsUpdate = true;
      lineGeometry.setDrawRange(0, lineIndex);

      // Camera movement
      const cameraDistance = 35 + currentLevel * 0.6;
      camera.position.x = Math.sin(animationTime * 0.15) * cameraDistance;
      camera.position.z = Math.cos(animationTime * 0.15) * cameraDistance;
      camera.position.y = 20 + Math.sin(animationTime * 0.12) * 10;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>