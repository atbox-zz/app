<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D到6D超立方體可視化</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100vw;
            height: 100vh;
            gap: 2px;
        }
        
        .panel {
            position: relative;
            background: rgba(0,0,0,0.1);
            border: 1px solid #444;
        }
        
        .label {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }
        
        .vertex-count {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #fff;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }
        
        .controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-size: 12px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            color: #fff;
            font-size: 12px;
            display: block;
            margin-bottom: 4px;
        }
        
        .control-group input {
            width: 80px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 4px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel" id="cube3DPanel">
            <div class="label">3D立方體</div>
            <div class="vertex-count">8個頂點</div>
            <div class="controls">
                <div class="control-group">
                    <label>旋轉速度:</label>
                    <input type="range" id="cube3DSpeed" min="0" max="0.05" step="0.001" value="0.01">
                </div>
                <div class="control-group">
                    <label>標籤顯示:</label>
                    <input type="checkbox" id="showLabels3D" checked>
                </div>
            </div>
        </div>
        
        <div class="panel" id="cube4DPanel">
            <div class="label">4D超立方體</div>
            <div class="vertex-count">16個頂點</div>
            <div class="controls">
                <div class="control-group">
                    <label>旋轉速度:</label>
                    <input type="range" id="cube4DSpeed" min="0" max="0.05" step="0.001" value="0.008">
                </div>
                <div class="control-group">
                    <label>點大小:</label>
                    <input type="range" id="point4DSize" min="1" max="8" step="0.5" value="2.5">
                </div>
                <div class="control-group">
                    <label>標籤顯示:</label>
                    <input type="checkbox" id="showLabels4D" checked>
                </div>
            </div>
        </div>
    <!--    
        <div class="panel" id="cube5DPanel">
            <div class="label">5D超立方體</div>
            <div class="vertex-count">32個頂點</div>
            <div class="controls">
                <div class="control-group">
                    <label>旋轉速度:</label>
                    <input type="range" id="cube5DSpeed" min="0" max="0.05" step="0.001" value="0.006">
                </div>
                <div class="control-group">
                    <label>點大小:</label>
                    <input type="range" id="point5DSize" min="1" max="8" step="0.5" value="2">
                </div>
                <div class="control-group">
                    <label>標籤顯示:</label>
                    <input type="checkbox" id="showLabels5D" checked>
                </div>
            </div>
        </div>
        
        <div class="panel" id="cube6DPanel">
            <div class="label">6D超立方體</div>
            <div class="vertex-count">64個頂點</div>
            <div class="controls">
                <div class="control-group">
                    <label>旋轉速度:</label>
                    <input type="range" id="cube6DSpeed" min="0" max="0.05" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <label>點大小:</label>
                    <input type="range" id="point6DSize" min="1" max="8" step="0.5" value="1.5">
                </div>
                <div class="control-group">
                    <label>標籤顯示:</label>
                    <input type="checkbox" id="showLabels6D" checked>
                </div>
            </div>
        </div>
    --> 
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 通用函數：生成n維超立方體頂點
        function generateVerticesND(dimensions) {
            const vertices = [];
            const totalVertices = Math.pow(2, dimensions);
            
            for (let i = 0; i < totalVertices; i++) {
                const binary = i.toString(2).padStart(dimensions, '0');
                const vertex = binary.split('').map(b => parseInt(b));
                vertices.push(vertex);
            }
            return vertices;
        }
        
        // 通用函數：檢查兩個n維頂點是否相鄰
        function areAdjacentND(v1, v2) {
            let diff = 0;
            for (let i = 0; i < v1.length; i++) {
                if (v1[i] !== v2[i]) diff++;
            }
            return diff === 1;
        }
        
        // 通用函數：將n維頂點投影到3D空間
        function projectNDto3D(vertexND, time, dimensions) {
            let x = vertexND[0] - 0.5;
            let y = vertexND[1] - 0.5;
            let z = vertexND[2] - 0.5;
            
            // 對於高維度，使用旋轉投影
            for (let i = 3; i < dimensions; i++) {
                const angle = time * (0.5 + i * 0.2);
                x += 0.3 * Math.cos(angle) * (vertexND[i] - 0.5);
                y += 0.3 * Math.sin(angle) * (vertexND[i] - 0.5);
                z += 0.3 * Math.cos(angle * 0.7) * (vertexND[i] - 0.5);
            }
            
            return [x, y, z];
        }
        
        // 通用函數：根據n維坐標生成顏色
        function getColorFromND(vertexND) {
            let r = 0, g = 0, b = 0;
            const dims = vertexND.length;
            
            switch(dims) {
                case 3:
                    r = vertexND[0];
                    g = vertexND[1];
                    b = vertexND[2];
                    break;
                case 4:
                    r = vertexND[0] * 0.8 + vertexND[3] * 0.2;
                    g = vertexND[1] * 0.8 + vertexND[3] * 0.2;
                    b = vertexND[2];
                    break;
                case 5:
                    r = (vertexND[0] + vertexND[3]) * 0.5;
                    g = (vertexND[1] + vertexND[4]) * 0.5;
                    b = vertexND[2];
                    break;
                case 6:
                    r = vertexND[0] * vertexND[3];
                    g = vertexND[1] * vertexND[4];
                    b = vertexND[2] * vertexND[5];
                    break;
            }
            
            return new THREE.Color(Math.max(0.2, r), Math.max(0.2, g), Math.max(0.2, b));
        }
        
        // 通用函數：創建n維超立方體
        function createNDCube(panelId, dimensions, speedId, sizeId, labelId) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            const panel = document.getElementById(panelId);
            const width = panel.offsetWidth;
            const height = panel.offsetHeight;
            
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);
            panel.appendChild(renderer.domElement);
            
            // 生成頂點
            const verticesND = generateVerticesND(dimensions);
            
            // 創建頂點mesh和標籤
            const vertexMeshes = [];
            const labels = [];
            
            verticesND.forEach((vertexND, index) => {
                const geometry = new THREE.SphereGeometry(0.02, 8, 8);
                const color = getColorFromND(vertexND);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                vertexMeshes.push({ mesh, vertexND });
                
                // 創建文字標籤
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = '#000000';
                context.font = 'bold 96px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                const coordText = `(${vertexND.join(',')})`;
                context.fillText(coordText, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.8
                });
                const label = new THREE.Sprite(labelMaterial);
                label.scale.set(0.3, 0.075, 1);
                scene.add(label);
                labels.push({ label, vertexND });
            });
            
            // 創建邊
            const lines = [];
            for (let i = 0; i < verticesND.length; i++) {
                for (let j = i + 1; j < verticesND.length; j++) {
                    if (areAdjacentND(verticesND[i], verticesND[j])) {
                        const geometry = new THREE.BufferGeometry();
                        const opacity = Math.max(0.1, 0.8 - dimensions * 0.1);
                        const material = new THREE.LineBasicMaterial({ 
                            color: 0x4488ff,
                            transparent: true,
                            opacity: opacity
                        });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        lines.push({ line, i, j });
                    }
                }
            }
            
            camera.position.set(2.5, 2.5, 2.5);
            camera.lookAt(0, 0, 0);
            
            // 動畫
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                
                time += 0.01;
                const speed = parseFloat(document.getElementById(speedId).value);
                const pointSize = sizeId ? parseFloat(document.getElementById(sizeId).value) : 3;
                
                // 更新頂點位置
                vertexMeshes.forEach(({ mesh, vertexND }) => {
                    if (dimensions === 3) {
                        // 3D立方體直接使用原始坐標
                        mesh.position.set(
                            vertexND[0] - 0.5,
                            vertexND[1] - 0.5,
                            vertexND[2] - 0.5
                        );
                    } else {
                        // 高維度使用投影
                        const pos3D = projectNDto3D(vertexND, time, dimensions);
                        mesh.position.set(pos3D[0], pos3D[1], pos3D[2]);
                    }
                    mesh.scale.setScalar(pointSize / 3);
                });
                
                // 更新標籤位置
                labels.forEach(({ label, vertexND }) => {
                    if (dimensions === 3) {
                        label.position.set(
                            vertexND[0] - 0.5,
                            vertexND[1] - 0.5 + 0.15,
                            vertexND[2] - 0.5
                        );
                    } else {
                        const pos3D = projectNDto3D(vertexND, time, dimensions);
                        label.position.set(pos3D[0], pos3D[1] + 0.15, pos3D[2]);
                    }
                });
                
                // 更新標籤顯示狀態
                const showLabels = labelId ? document.getElementById(labelId).checked : true;
                labels.forEach(({ label }) => {
                    label.visible = showLabels;
                });
                
                // 更新連接線
                lines.forEach(({ line, i, j }) => {
                    let pos1, pos2;
                    if (dimensions === 3) {
                        pos1 = [
                            verticesND[i][0] - 0.5,
                            verticesND[i][1] - 0.5,
                            verticesND[i][2] - 0.5
                        ];
                        pos2 = [
                            verticesND[j][0] - 0.5,
                            verticesND[j][1] - 0.5,
                            verticesND[j][2] - 0.5
                        ];
                    } else {
                        pos1 = projectNDto3D(verticesND[i], time, dimensions);
                        pos2 = projectNDto3D(verticesND[j], time, dimensions);
                    }
                    
                    const points = [
                        new THREE.Vector3(pos1[0], pos1[1], pos1[2]),
                        new THREE.Vector3(pos2[0], pos2[1], pos2[2])
                    ];
                    line.geometry.setFromPoints(points);
                });
                
                scene.rotation.x += speed;
                scene.rotation.y += speed * 1.2;
                
                renderer.render(scene, camera);
            }
            animate();
            
            // 響應式調整
            window.addEventListener('resize', () => {
                const width = panel.offsetWidth;
                const height = panel.offsetHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }
        
        // 初始化所有維度的立方體
        window.addEventListener('load', () => {
            createNDCube('cube3DPanel', 3, 'cube3DSpeed', null, 'showLabels3D');
            createNDCube('cube4DPanel', 4, 'cube4DSpeed', 'point4DSize', 'showLabels4D');
//            createNDCube('cube5DPanel', 5, 'cube5DSpeed', 'point5DSize', 'showLabels5D');
//            createNDCube('cube6DPanel', 6, 'cube6DSpeed', 'point6DSize', 'showLabels6D');
        });
    </script>
</body>
</html>