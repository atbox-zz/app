<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>é‡å­DNA Â· å²è©©èºæ—‹</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Microsoft JhengHei', Arial, sans-serif;
      height: 100vh;
      color: white;
    }
    #container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 255, 255, 0.9);
      color: #000;
      font-size: 24px;
      font-weight: bold;
      padding: 30px 60px;
      border-radius: 15px;
      cursor: pointer;
      z-index: 100;
      border: 3px solid #fff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
      transition: transform 0.3s;
    }
    #start-btn:hover {
      transform: translate(-50%, -50%) scale(1.1);
    }
    .title {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 42px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
      z-index: 10;
    }
    .footer {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 18px;
      text-align: center;
      z-index: 10;
      opacity: 0.9;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .stats {
      position: absolute;
      top: 30px;
      left: 30px;
      color: #0ff;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      z-index: 10;
      background: rgba(0,0,0,0.8);
      padding: 15px 20px;
      border-radius: 8px;
      border: 2px solid #0ff;
      box-shadow: 0 0 20px rgba(0,255,255,0.3);
    }
    .credit {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255,255,255,0.5);
      font-size: 10px;
      z-index: 10;
    }
    #control-buttons {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
            background: rgba(0, 0, 0, .6);
            padding: 10px 15px;
            border-radius: 10px;
             border: 1px solid rgba(255, 120, 50, .2);
        }
        .control-button {
            background: rgba(255, 120, 50, .2);
            color: #eee;
            border: 1px solid rgba(255, 150, 50, .3);
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            white-space: nowrap;
            min-width: 80px;
            text-align: center;
            font-family: 'Inter', sans-serif;
        }
        .control-button:hover, .control-button:focus {
            background: rgba(255, 120, 50, .4);
            outline: none;
        }
        .control-button:active {
            background: rgba(255, 120, 50, .6);
            transform: scale(0.95);
        }

        /* æ–°å¢éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ•æ¨£å¼ */
        #music-control-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, .6);
            border: 1px solid rgba(255, 120, 50, .2);
            padding: 8px 15px;
            border-radius: 10px;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        #music-control-btn:hover {
            background: rgba(255, 120, 50, .4);
        }

        @media (max-width: 640px) {
            #instructions-container {
                max-width: calc(100% - 40px);
                font-size: 13px;
                padding: 10px 15px;
                top: 10px;
                left: 10px;
            }
            #instruction-title {
                font-size: 14px;
            }
            /* é‡å°æ›´å°è¢å¹•çš„ä¸»é¡Œé¸æ“‡å™¨éŸ¿æ‡‰å¼æ¨£å¼ä¹Ÿè¨­å®šç‚ºéš±è— */
             #theme-selector {
                display: none;
            }
             #theme-selector-title {
                font-size: 14px;
            }
            .theme-button {
                width: 30px;
                height: 30px;
            }
            .density-label { font-size: 12px; }
            #control-buttons {
                bottom: 10px;
                gap: 10px;
                padding: 8px 10px;
            }
            .control-button {
                padding: 6px 10px;
                font-size: 12px;
                min-width: 65px;
            }
            /* åœ¨å°è¢å¹•ä¸Šå°‡éŸ³æ¨‚æŒ‰éˆ•ç§»å‹•åˆ°æ§åˆ¶åˆ—ä¸‹æ–¹ */
            #music-control-btn {
                bottom: 0px;
                right: 0px;
            }
        }
         @media (max-width: 400px) {
            /* é‡å°æ›´å°è¢å¹•çš„ä¸»é¡Œé¸æ“‡å™¨éŸ¿æ‡‰å¼æ¨£å¼ä¹Ÿè¨­å®šç‚ºéš±è— */
             #theme-selector {
                display: none;
            }
             .theme-grid {
                grid-template-columns: repeat(4, 1fr);
                width: 100%;
                justify-items: center;
            }
             #density-controls {
                width: 80%;
                margin-top: 15px;
            }
             #control-buttons {
                width: calc(100% - 20px);
                justify-content: space-around;
                bottom: 10px;
            }
            #music-control-btn {
                bottom: 60px;
                right: 10px;
                left: 10px;
                width: calc(100% - 20px);
                text-align: center;
            }
        }
    /* åœ¨å°è¢å¹•ä¸Šå°‡éŸ³æ¨‚æŒ‰éˆ•ç§»å‹•åˆ°æ§åˆ¶åˆ—ä¸‹æ–¹ */
    #music-control-btn {
      bottom: 70px;
      right: 10px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!--div id="start-btn">ğŸµ é»æ“Šé–‹å§‹å²è©©ä¹‹æ—… ğŸµ</div-->

  <div class="title" id="title">2<sup>0</sup> = 1</div>

  <div class="footer">
    ç„¡é™æ–¹å‘DNAèºæ—‹ç¶²çµ¡ Â· äº‚ä¸­æœ‰åº Â· å°æ•¸çˆ†ç‚¸æˆé•·
  </div>

  <!---div class="stats" id="stats">
    <div style="margin-bottom:8px;font-size:16px;font-weight:bold;">ç­‰ç´š 0 / 256</div>
    <div style="margin-bottom:5px;">ç†è«–ç²’å­: 1</div>
    <div style="margin-bottom:5px;">é¡¯ç¤ºç²’å­: 1</div>
    <div style="margin-bottom:8px;font-size:16px;color:#ff0;font-weight:bold;">èºæ—‹æ•¸é‡: 1</div>
    <div style="font-size:12px;opacity:0.8;font-style:italic;">æ··æ²Œåˆé–‹...</div>
  </div-->

  <!-- æ–°å¢éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ• --------------------------------------------------------->
    <button id="music-control-btn" class="control-button">æ’­æ”¾éŸ³æ¨‚</button>
      <audio id="background-music" loop>
            <source src="epic-cinematic-trailer.mp3" type="audio/mpeg">
      </audio>

      <div class="credit">
    Music: "Epic Cinematic Trailer" by Lexin Music (CC BY 4.0)
  </div>

  <!-- Load libraries from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <script>
    // DOM references
    const container = document.getElementById('container');
    //const startBtn = document.getElementById('start-btn');
    const titleEl = document.getElementById('title');
    const statsEl = document.getElementById('stats');

    // State
    let growthLevel = 0;
    let particleCount = 1;
    let activeCount = 1;
    let helixCount = 1;
    let audioStarted = false;

    // Initialize Three.js
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 30, 100);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(30, 20, 30);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Particle system
    const maxParticles = 100000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3);
    const colors = new Float32Array(maxParticles * 3);

    for (let i = 0; i < maxParticles; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 60;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 60;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
      colors[i * 3] = 0.2;
      colors[i * 3 + 1] = 0.3;
      colors[i * 3 + 2] = 0.5;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.35,
      vertexColors: true,
      transparent: true,
      opacity: 0.85,
      sizeAttenuation: true
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // Line system
    const lineGeometry = new THREE.BufferGeometry();
    const linePositions = new Float32Array(maxParticles * 12);
    const lineColors = new Float32Array(maxParticles * 12);
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));

    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending
    });

    const lineSystem = new THREE.LineSegments(lineGeometry, lineMaterial);
    scene.add(lineSystem);

    // Directions
    const directions = [
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(-1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, -1, 0),
      new THREE.Vector3(0, 0, 1),
      new THREE.Vector3(0, 0, -1),
      new THREE.Vector3(0.707, 0.707, 0),
      new THREE.Vector3(-0.707, 0.707, 0),
      new THREE.Vector3(0.707, -0.707, 0),
      new THREE.Vector3(-0.707, -0.707, 0),
      new THREE.Vector3(0.707, 0, 0.707),
      new THREE.Vector3(-0.707, 0, 0.707),
      new THREE.Vector3(0.707, 0, -0.707),
      new THREE.Vector3(-0.707, 0, -0.707),
      new THREE.Vector3(0, 0.707, 0.707),
      new THREE.Vector3(0, -0.707, 0.707),
    ];

    const getHelixCount = (level) => {
      if (level === 0) return 1;
      return Math.min(Math.pow(2, Math.floor(level / 2)), 10000);
    };

    const getDNAPosition = (index, total, level) => {
      const currentHelixCount = getHelixCount(level);
      const particlesPerHelix = Math.max(Math.floor(total / currentHelixCount), 1);
      const helixIndex = Math.floor(index / particlesPerHelix);
      const indexInHelix = index % particlesPerHelix;
      const progressInHelix = indexInHelix / Math.max(particlesPerHelix, 1);

      const directionIndex = helixIndex % directions.length;
      const baseDirection = directions[directionIndex].clone();
      const randomOffset = new THREE.Vector3(
        Math.sin(helixIndex * 2.718) * 0.3,
        Math.cos(helixIndex * 3.141) * 0.3,
        Math.sin(helixIndex * 1.618) * 0.3
      );
      const direction = baseDirection.clone().add(randomOffset).normalize();

      const turns = 8 + (level * 0.3);
      const angle = progressInHelix * Math.PI * 2 * turns;
      const length = progressInHelix * (15 + level * 0.8);
      const strand = indexInHelix % 2;
      const strandPhase = strand * Math.PI;
      const spiralRadius = 1.5 + Math.sin(progressInHelix * Math.PI * 6) * 0.4;

      const perpendicular1 = new THREE.Vector3();
      const perpendicular2 = new THREE.Vector3();
      if (Math.abs(direction.y) < 0.9) {
        perpendicular1.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
      } else {
        perpendicular1.crossVectors(direction, new THREE.Vector3(1, 0, 0)).normalize();
      }
      perpendicular2.crossVectors(direction, perpendicular1).normalize();

      const centerPos = direction.clone().multiplyScalar(length);
      const spiralOffset = perpendicular1.clone()
        .multiplyScalar(Math.cos(angle + strandPhase) * spiralRadius)
        .add(perpendicular2.clone().multiplyScalar(Math.sin(angle + strandPhase) * spiralRadius));
      const finalPos = centerPos.add(spiralOffset);

      return { pos: finalPos, helixIndex, strandIndex: strand, progressInHelix, indexInHelix };
    };

    const getColor = (helixIndex, progress) => {
      const hue = ((helixIndex * 0.618033988749895) % 1) * 0.85 + progress * 0.15;
      const saturation = 0.8 + Math.sin(progress * Math.PI * 4) * 0.15;
      const lightness = 0.5 + Math.sin(helixIndex * 1.234 + progress * Math.PI * 2) * 0.2;
      return new THREE.Color().setHSL(hue, saturation, lightness);
    };

    // Audio setup
    let audioInitialized = false;
    const initAudio = async () => {
      if (audioInitialized) return;
      audioInitialized = true;

      try {
        await Tone.start();

        const reverb = new Tone.Reverb({ decay: 5, wet: 0.35 }).toDestination();
        const player = new Tone.Player({
          url: 'https://cdn.jsdelivr.net/gh/lexin-music/epic-cinematic-trailer@main/epic-cinematic-trailer.mp3',
          loop: true,
          volume: -10
        }).connect(reverb);

        player.on('load', () => {
          player.start(0);
          audioStarted = true;
          //startBtn.style.display = 'none';
        });

        player.on('error', (err) => {
          console.error('Audio load error:', err);
          audioStarted = true;
          //startBtn.style.display = 'none';
        });
      } catch (err) {
        console.error('Tone start error:', err);
        //startBtn.style.display = 'none';
      }
    };

    //startBtn.addEventListener('click', initAudio);

    // Animation loop
    let currentLevel = 0;
    let currentActiveCount = 1;
    let lastUpdate = Date.now();
    let animationTime = 0;

    const animate = () => {
      requestAnimationFrame(animate);
      animationTime += 0.01;

      const now = Date.now();
      if (now - lastUpdate >= 1000 && currentLevel < 256) {
        currentLevel++;
        currentActiveCount = Math.min(Math.pow(2, currentLevel), maxParticles);
        const currentHelixCount = getHelixCount(currentLevel);
        lastUpdate = now;

        // Update state
        growthLevel = currentLevel;
        particleCount = Math.pow(2, currentLevel);
        activeCount = currentActiveCount;
        helixCount = currentHelixCount;

        // Update UI
        const formatNumber = (num) => {
          if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
          if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
          if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
          if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
          return num.toLocaleString();
        };

        titleEl.innerHTML = `2<sup>${growthLevel}</sup> = ${formatNumber(particleCount)}`;

        const statusText = growthLevel < 10 ? 'æ··æ²Œåˆé–‹...' :
                          growthLevel < 20 ? 'ç§©åºæ¼¸ç¾...' :
                          growthLevel < 30 ? 'çµæ§‹çˆ†ç™¼...' :
                          growthLevel < 40 ? 'ç¶²çµ¡æ“´å¼µ...' :
                          growthLevel < 50 ? 'æŒ‡æ•¸æˆé•·...' :
                          growthLevel < 60 ? 'è¶¨å‘ç„¡é™...' : 'å®‡å®™æ¥µé™...';

        statsEl.innerHTML = `
          <div style="margin-bottom:8px;font-size:16px;font-weight:bold;">ç­‰ç´š ${growthLevel} / 256</div>
          <div style="margin-bottom:5px;">ç†è«–ç²’å­: ${formatNumber(particleCount)}</div>
          <div style="margin-bottom:5px;">é¡¯ç¤ºç²’å­: ${activeCount.toLocaleString()}</div>
          <div style="margin-bottom:8px;font-size:16px;color:#ff0;font-weight:bold;">èºæ—‹æ•¸é‡: ${helixCount.toLocaleString()}</div>
          <div style="font-size:12px;opacity:0.8;font-style:italic;">${statusText}</div>
        `;
      }

      const posArray = geometry.attributes.position.array;
      const colorArray = geometry.attributes.color.array;
      const linePos = lineGeometry.attributes.position.array;
      const lineCol = lineGeometry.attributes.color.array;

      let lineIndex = 0;
      const currentHelixCount = getHelixCount(currentLevel);
      const particlesPerHelix = Math.max(Math.floor(currentActiveCount / currentHelixCount), 1);

      for (let i = 0; i < maxParticles; i++) {
        if (i < currentActiveCount) {
          const dnaData = getDNAPosition(i, currentActiveCount, currentLevel);
          const targetPos = dnaData.pos;
          const quantum = Math.sin(animationTime * 2.5 + i * 0.08) * 0.12;

          posArray[i * 3] += (targetPos.x + quantum - posArray[i * 3]) * 0.05;
          posArray[i * 3 + 1] += (targetPos.y + quantum - posArray[i * 3 + 1]) * 0.05;
          posArray[i * 3 + 2] += (targetPos.z + quantum - posArray[i * 3 + 2]) * 0.05;

          const color = getColor(dnaData.helixIndex, dnaData.progressInHelix);
          colorArray[i * 3] += (color.r - colorArray[i * 3]) * 0.05;
          colorArray[i * 3 + 1] += (color.g - colorArray[i * 3 + 1]) * 0.05;
          colorArray[i * 3 + 2] += (color.b - colorArray[i * 3 + 2]) * 0.05;

          // Connect next in helix
          const nextInHelix = i + 1;
          if (nextInHelix < currentActiveCount && 
              Math.floor(nextInHelix / particlesPerHelix) === dnaData.helixIndex &&
              lineIndex < maxParticles * 4) {
            const nextData = getDNAPosition(nextInHelix, currentActiveCount, currentLevel);
            if (nextData.strandIndex === dnaData.strandIndex) {
              linePos.set([posArray[i*3], posArray[i*3+1], posArray[i*3+2], posArray[nextInHelix*3], posArray[nextInHelix*3+1], posArray[nextInHelix*3+2]], lineIndex * 3);
              lineCol.set([colorArray[i*3], colorArray[i*3+1], colorArray[i*3+2], colorArray[nextInHelix*3], colorArray[nextInHelix*3+1], colorArray[nextInHelix*3+2]], lineIndex * 3);
              lineIndex += 2;
            }
          }

          // Connect strands
          if (dnaData.indexInHelix % 4 === 0 && lineIndex < maxParticles * 4) {
            const pairIndex = dnaData.strandIndex === 0 ? i + 1 : i - 1;
            const pairHelixStart = dnaData.helixIndex * particlesPerHelix;
            if (pairIndex >= pairHelixStart && pairIndex < pairHelixStart + particlesPerHelix && pairIndex < currentActiveCount) {
              linePos.set([posArray[i*3], posArray[i*3+1], posArray[i*3+2], posArray[pairIndex*3], posArray[pairIndex*3+1], posArray[pairIndex*3+2]], lineIndex * 3);
              const dim = 0.6;
              lineCol.set([
                colorArray[i*3]*dim, colorArray[i*3+1]*dim, colorArray[i*3+2]*dim,
                colorArray[pairIndex*3]*dim, colorArray[pairIndex*3+1]*dim, colorArray[pairIndex*3+2]*dim
              ], lineIndex * 3);
              lineIndex += 2;
            }
          }
        } else {
          colorArray[i * 3] += (0.05 - colorArray[i * 3]) * 0.02;
          colorArray[i * 3 + 1] += (0.05 - colorArray[i * 3 + 1]) * 0.02;
          colorArray[i * 3 + 2] += (0.1 - colorArray[i * 3 + 2]) * 0.02;
        }
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;
      lineGeometry.attributes.position.needsUpdate = true;
      lineGeometry.attributes.color.needsUpdate = true;
      lineGeometry.setDrawRange(0, lineIndex);

      // Camera movement
      const cameraDistance = 35 + currentLevel * 0.6;
      camera.position.x = Math.sin(animationTime * 0.15) * cameraDistance;
      camera.position.z = Math.cos(animationTime * 0.15) * cameraDistance;
      camera.position.y = 20 + Math.sin(animationTime * 0.12) * 10;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    };

    animate();
    // ========================
    // æ–°å¢éŸ³æ¨‚æ§åˆ¶åŠŸèƒ½
    // ========================
    const musicControlBtn = document.getElementById('music-control-btn');
    const backgroundMusic = document.getElementById('background-music');

    musicControlBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (backgroundMusic.paused) {
          backgroundMusic.play().catch(error => {
              console.warn("ç„¡æ³•è‡ªå‹•æ’­æ”¾éŸ³æ¨‚ï¼Œè«‹åœ¨ä½¿ç”¨è€…äº’å‹•å¾Œå†è©¦ä¸€æ¬¡ã€‚", error);
              alert("è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨éŸ³æ¨‚æ’­æ”¾ã€‚");
          });
          musicControlBtn.textContent = "æš«åœéŸ³æ¨‚";
      } else {
          backgroundMusic.pause();
          musicControlBtn.textContent = "æ’­æ”¾éŸ³æ¨‚";
      }
    });
    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>