<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線性規劃單形法可視化工具 - 進階版</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --success: #2ecc71;
            --warning: #f39c12;
            --light: #ecf0f1;
            --dark: #34495e;
            --purple: #9b59b6;
            --orange: #e67e22;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--light);
            padding: 20px;
            min-height: 100vh;
            overflow-x: auto;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 30px 20px;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #fff, #a8e6cf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1000px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }
        
        .panel-title {
            font-size: 1.6rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary);
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .icon {
            font-size: 1.5rem;
        }
        
        .problem-input {
            display: grid;
            gap: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        label {
            font-weight: 600;
            color: var(--light);
            font-size: 1rem;
        }
        
        input, select, textarea {
            padding: 14px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
            transform: translateY(-2px);
        }
        
        button {
            background: linear-gradient(45deg, var(--secondary), var(--purple));
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: linear-gradient(45deg, #7f8c8d, #95a5a6);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .controls button {
            flex: 1;
        }
        
        .btn-reset {
            background: linear-gradient(45deg, var(--accent), #c0392b);
        }
        
        .btn-next {
            background: linear-gradient(45deg, var(--success), #27ae60);
        }
        
        .btn-prev {
            background: linear-gradient(45deg, var(--warning), #d68910);
        }
        
        .result-panel {
            grid-column: 1 / -1;
        }
        
        .tableau-container {
            overflow-x: auto;
            margin-top: 20px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.1);
            padding: 15px;
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        th {
            background: linear-gradient(45deg, var(--dark), var(--primary));
            padding: 16px 12px;
            text-align: center;
            font-weight: 700;
            color: white;
            font-size: 0.9rem;
        }
        
        td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        tr:hover td {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        .pivot {
            background: linear-gradient(45deg, rgba(231, 76, 60, 0.7), rgba(192, 57, 43, 0.7));
            font-weight: bold;
            position: relative;
            animation: pulse 2s infinite;
        }
        
        .pivot::after {
            content: attr(data-pivot-label);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 6px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }
        
        .basis {
            background: linear-gradient(45deg, rgba(46, 204, 113, 0.3), rgba(39, 174, 96, 0.3));
        }
        
        .entering {
            background: linear-gradient(45deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
        }
        
        .solution-box {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .solution-card {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1));
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .solution-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .solution-card h3 {
            margin-bottom: 15px;
            color: var(--light);
            font-size: 1.2rem;
        }
        
        .solution-value {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--success), #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .variables {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .variable {
            background: linear-gradient(45deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            padding: 10px 18px;
            border-radius: 25px;
            font-weight: 600;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }
        
        .step-info {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1));
            border-radius: 15px;
            line-height: 1.7;
            border-left: 4px solid var(--secondary);
        }
        
        .step-title {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--success));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .case-description {
            background: linear-gradient(145deg, rgba(52, 152, 219, 0.1), rgba(41, 128, 185, 0.1));
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            line-height: 1.7;
        }
        
        .case-description h3 {
            color: var(--secondary);
            margin-bottom: 15px;
            margin-top: 25px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .case-description h3:first-child {
            margin-top: 0;
        }
        
        .case-description ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        .case-description li {
            margin-bottom: 10px;
        }
        
        .instructions {
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1));
            border-radius: 20px;
            line-height: 1.8;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .instructions h2 {
            margin-bottom: 20px;
            color: white;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .instructions ul {
            padding-left: 30px;
            margin-top: 15px;
        }
        
        .instructions li {
            margin-bottom: 15px;
        }
        
        .instructions code {
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            color: var(--warning);
            font-weight: 600;
        }
        
        .highlight {
            color: var(--success);
            font-weight: bold;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 6px;
        }
        
        .legend-pivot {
            background: linear-gradient(45deg, rgba(231, 76, 60, 0.7), rgba(192, 57, 43, 0.7));
        }
        
        .legend-basis {
            background: linear-gradient(45deg, rgba(46, 204, 113, 0.3), rgba(39, 174, 96, 0.3));
        }
        
        .legend-entering {
            background: linear-gradient(45deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
        }

        .error-message {
            background: linear-gradient(45deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 18px;
            margin: 15px 0;
            color: white;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            line-height: 1.6;
        }

        .algorithm-info {
            background: linear-gradient(145deg, rgba(155, 89, 182, 0.1), rgba(142, 68, 173, 0.1));
            border: 2px solid rgba(155, 89, 182, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            line-height: 1.7;
        }

        .algorithm-info h3 {
            color: var(--purple);
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-counter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .counter {
            background: var(--secondary);
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .sensitivity-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 20px;
        }

        .feasible-region {
            margin-top: 20px;
            height: 400px;
        }

        .language-select {
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-key="title">🎯 線性規劃單形法可視化解決方案</h1>
            <p class="subtitle" data-key="subtitle">
                此工具採用單形法 (Simplex Method) 求解線性規劃問題，並提供完整的計算過程可視化。
                適用於生產規劃、資源分配、利潤最大化等實際商業問題的求解與教學。
            </p>
        </header>
        
        <select id="language" class="language-select">
            <option value="zh">中文</option>
            <option value="en">English</option>
        </select>

        <div class="content">
            <div class="panel">
                <h2 class="panel-title">
                    <span class="icon">📊</span>
                    <span data-key="problem_input">問題輸入</span>
                </h2>
                <div class="problem-input">
                    <div class="input-group">
                        <label for="objective" data-key="objective_type">🎯 目標函數類型</label>
                        <select id="objective">
                            <option value="max" data-key="maximize">最大化 (Maximize)</option>
                            <option value="min" data-key="minimize">最小化 (Minimize)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="function" data-key="objective_coeffs">💰 目標函數係數 (用逗號分隔，例如: 800,1200)</label>
                        <input type="text" id="function" value="800,1200" placeholder="例如: 800,1200">
                    </div>
                    
                    <div class="input-group">
                        <label for="constraints" data-key="constraints">⚖️ 約束條件 (每行一個約束，格式: 係數1,係數2,運算符,常數)</label>
                        <textarea id="constraints" rows="6">4,6,<=,2400
2,2,<=,800
1,3,<=,900
1,0,<=,300
0,1,<=,250</textarea>
                    </div>
                    
                    <button id="solve-btn" data-key="solve">🚀 求解問題</button>
                </div>
            </div>
            
            <div class="panel">
                <h2 class="panel-title">
                    <span class="icon">🎮</span>
                    <span data-key="calculation_control">計算控制</span>
                </h2>
                
                <div class="step-counter">
                    <span data-key="current_step">當前步驟：</span>
                    <span class="counter" id="step-counter">0 / 0</span>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                
                <div class="controls">
                    <button id="prev-btn" class="btn-prev" disabled data-key="previous">⬅️ 上一步</button>
                    <button id="next-btn" class="btn-next" disabled data-key="next">下一步 ➡️</button>
                    <button id="reset-btn" class="btn-reset" data-key="reset">🔄 重置</button>
                </div>
                
                <div class="step-info">
                    <h3 class="step-title">
                        <span>📝</span>
                        <span data-key="step_explanation">步驟說明</span>
                    </h3>
                    <p id="step-description" data-key="initial_description">點擊"求解"按鈕開始計算。求解完成後，使用"下一步"按鈕查看單形法的每一步運算過程。</p>
                </div>
                
                <div class="solution-box">
                    <div class="solution-card">
                        <h3 data-key="optimal_solution">🏭 最優解 (生產數量)</h3>
                        <div class="variables" id="solution-variables">
                            <div class="variable" data-key="variable_x1">5nm晶片 = <span id="x1">0</span> 片</div>
                            <div class="variable" data-key="variable_x2">3nm晶片 = <span id="x2">0</span> 片</div>
                        </div>
                    </div>
                    
                    <div class="solution-card">
                        <h3 data-key="max_profit">💰 最大利潤</h3>
                        <div class="solution-value" id="optimal-value">0</div>
                        <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.8;" data-key="currency">萬台幣</div>
                    </div>
                </div>

                <canvas id="feasible-region" class="feasible-region"></canvas>

                <div class="sensitivity-panel" id="sensitivity-panel">
                    <h3 data-key="sensitivity_analysis">敏感性分析</h3>
                    <div id="shadow-prices"></div>
                    <div id="range-analysis"></div>
                </div>
            </div>
            
            <div class="panel result-panel">
                <h2 class="panel-title">
                    <span class="icon">📋</span>
                    <span data-key="tableau_process">單形表計算過程</span>
                </h2>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color legend-pivot"></div>
                        <span data-key="pivot_element">樞軸元素 (Pivot Element)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-basis"></div>
                        <span data-key="basic_variables">基變量 (Basic Variables)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-entering"></div>
                        <span data-key="entering_variable">進入變量 (Entering Variable)</span>
                    </div>
                </div>
                
                <div class="tableau-container" id="tableau-container">
                    <p class="step-info" data-key="input_prompt">輸入問題並點擊"求解"按鈕後，這裡將顯示計算過程。</p>
                </div>
            </div>
        </div>
        
        <div class="case-description">
            <h3 data-key="case_title">🏢 實際案例：台積電晶片生產規劃</h3>
            <p data-key="case_description">
                本工具以台積電晶片生產為例，展示線性規劃在實際製造業中的應用。
                假設台積電需要決定5nm和3nm晶片的最優生產配置，以最大化利潤。
            </p>
            
            <h3 data-key="problem_setup">📊 問題設定</h3>
            <ul>
                <li data-key="decision_variables"><strong>決策變量：</strong>x₁ = 5nm晶片生產數量，x₂ = 3nm晶片生產數量</li>
                <li data-key="objective_function"><strong>目標函數：</strong>最大化利潤 = 800x₁ + 1200x₂ (萬台幣)</li>
                <li data-key="constraints_title"><strong>約束條件：</strong>
                    <ul>
                        <li data-key="constraint1">設備時間限制：4x₁ + 6x₂ ≤ 2400 (小時)</li>
                        <li data-key="constraint2">原料限制：2x₁ + 2x₂ ≤ 800 (單位)</li>
                        <li data-key="constraint3">技術人員限制：x₁ + 3x₂ ≤ 900 (人時)</li>
                        <li data-key="constraint4">5nm產能上限：x₁ ≤ 300 (片)</li>
                        <li data-key="constraint5">3nm產能上限：x₂ ≤ 250 (片)</li>
                    </ul>
                </li>
            </ul>
            
            <h3 data-key="learning_objectives">🎯 學習目標</h3>
            <ul>
                <li data-key="learning1">理解線性規劃問題的標準形式轉換</li>
                <li data-key="learning2">掌握單形法的計算步驟與樞軸運算</li>
                <li data-key="learning3">學習如何解讀單形表中的數據意義</li>
                <li data-key="learning4">了解基變量、非基變量的概念</li>
                <li data-key="learning5">掌握最優性檢驗與解的判定</li>
            </ul>
        </div>
        
        <div class="algorithm-info">
            <h3 data-key="algorithm_title">🧮 單形法算法說明</h3>
            <p data-key="algorithm_description">
                單形法 (Simplex Method) 是求解線性規劃問題最經典的算法，由 George Dantzig 於1947年提出。
                該算法通過系統性地移動到相鄰的基可行解，逐步改善目標函數值，直到找到最優解。
            </p>
            <ul>
                <li data-key="algorithm_step1"><strong>第一步：</strong>將問題轉換為標準形式，添加鬆弛變數</li>
                <li data-key="algorithm_step2"><strong>第二步：</strong>建立初始單形表，找到初始基可行解</li>
                <li data-key="algorithm_step3"><strong>第三步：</strong>檢查最優性條件（目標函數行係數）</li>
                <li data-key="algorithm_step4"><strong>第四步：</strong>若未達最優，選擇進入變數和離開變數</li>
                <li data-key="algorithm_step5"><strong>第五步：</strong>執行樞軸運算，更新單形表</li>
                <li data-key="algorithm_step6"><strong>重複步驟3-5</strong>直到達到最優解</li>
            </ul>
        </div>
        
        <div class="instructions">
            <h2 data-key="instructions_title">📖 詳細使用說明</h2>
            <ul>
                <li data-key="instruction1"><span class="highlight">目標函數設定</span>：輸入目標函數的係數，用逗號分隔。例如最大化利潤 z = 800x₁ + 1200x₂ 應輸入 <code>800,1200</code></li>
                <li data-key="instruction2"><span class="highlight">約束條件格式</span>：每行輸入一個約束條件，格式為 <code>係數1,係數2,運算符,常數</code>。例如 4x₁ + 6x₂ ≤ 2400 應輸入 <code>4,6,<=,2400</code></li>
                <li data-key="instruction3"><span class="highlight">支持運算符</span>：<code>&lt;=</code> (小於等於), <code>=</code> (等於), <code>&gt;=</code> (大於等於)</li>
                <li data-key="instruction4"><span class="highlight">求解過程</span>：點擊"求解"按鈕後，系統將自動計算並顯示初始單形表</li>
                <li data-key="instruction5"><span class="highlight">逐步演示</span>：使用"下一步"按鈕查看單形法的每一步計算過程</li>
                <li data-key="instruction6"><span class="highlight">視覺化元素</span>：表格中不同顏色標示不同類型的變數和操作</li>
                <li data-key="instruction7"><span class="highlight">進度追蹤</span>：頂部進度條顯示當前求解進度</li>
            </ul>
        </div>
        
        <footer>
            <p><strong data-key="footer_title">🎓 線性規劃單形法可視化教學工具</strong></p>
            <p data-key="footer_description">
                本工具專為線性規劃教學設計，幫助學生理解單形法的計算原理和實際應用。
                適用於運籌學、管理科學、工業工程等相關課程的教學與自學。
            </p>
            <p style="margin-top: 15px;">
                <em data-key="footer_tip">💡 提示：建議配合教科書內容使用，深入理解</em>
            </p>
        </footer>
    </div>

    <script>
        // 多語言支援
        const translations = {
            zh: {
                title: '🎯 線性規劃單形法可視化解決方案',
                subtitle: '此工具採用單形法 (Simplex Method) 求解線性規劃問題，並提供完整的計算過程可視化。適用於生產規劃、資源分配、利潤最大化等實際商業問題的求解與教學。',
                problem_input: '問題輸入',
                objective_type: '🎯 目標函數類型',
                maximize: '最大化 (Maximize)',
                minimize: '最小化 (Minimize)',
                objective_coeffs: '💰 目標函數係數 (用逗號分隔，例如: 800,1200)',
                constraints: '⚖️ 約束條件 (每行一個約束，格式: 係數1,係數2,運算符,常數)',
                solve: '🚀 求解問題',
                calculation_control: '計算控制',
                current_step: '當前步驟：',
                previous: '⬅️ 上一步',
                next: '下一步 ➡️',
                reset: '🔄 重置',
                step_explanation: '步驟說明',
                initial_description: '點擊"求解"按鈕開始計算。求解完成後，使用"下一步"按鈕查看單形法的每一步運算過程。',
                optimal_solution: '🏭 最優解 (生產數量)',
                max_profit: '💰 最大利潤',
                currency: '萬台幣',
                variable_x1: '5nm晶片 = <span id="x1">0</span> 片',
                variable_x2: '3nm晶片 = <span id="x2">0</span> 片',
                tableau_process: '單形表計算過程',
                pivot_element: '樞軸元素 (Pivot Element)',
                basic_variables: '基變量 (Basic Variables)',
                entering_variable: '進入變量 (Entering Variable)',
                input_prompt: '輸入問題並點擊"求解"按鈕後，這裡將顯示計算過程。',
                sensitivity_analysis: '敏感性分析',
                shadow_prices: '影價',
                range_analysis: '範圍分析',
                case_title: '🏢 實際案例：台積電晶片生產規劃',
                case_description: '本工具以台積電晶片生產為例，展示線性規劃在實際製造業中的應用。假設台積電需要決定5nm和3nm晶片的最優生產配置，以最大化利潤。',
                problem_setup: '📊 問題設定',
                decision_variables: '<strong>決策變量：</strong>x₁ = 5nm晶片生產數量，x₂ = 3nm晶片生產數量',
                objective_function: '<strong>目標函數：</strong>最大化利潤 = 800x₁ + 1200x₂ (萬台幣)',
                constraints_title: '<strong>約束條件：</strong>',
                constraint1: '設備時間限制：4x₁ + 6x₂ ≤ 2400 (小時)',
                constraint2: '原料限制：2x₁ + 2x₂ ≤ 800 (單位)',
                constraint3: '技術人員限制：x₁ + 3x₂ ≤ 900 (人時)',
                constraint4: '5nm產能上限：x₁ ≤ 300 (片)',
                constraint5: '3nm產能上限：x₂ ≤ 250 (片)',
                learning_objectives: '🎯 學習目標',
                learning1: '理解線性規劃問題的標準形式轉換',
                learning2: '掌握單形法的計算步驟與樞軸運算',
                learning3: '學習如何解讀單形表中的數據意義',
                learning4: '了解基變量、非基變量的概念',
                learning5: '掌握最優性檢驗與解的判定',
                algorithm_title: '🧮 單形法算法說明',
                algorithm_description: '單形法 (Simplex Method) 是求解線性規劃問題最經典的算法，由 George Dantzig 於1947年提出。該算法通過系統性地移動到相鄰的基可行解，逐步改善目標函數值，直到找到最優解。',
                algorithm_step1: '<strong>第一步：</strong>將問題轉換為標準形式，添加鬆弛變數',
                algorithm_step2: '<strong>第二步：</strong>建立初始單形表，找到初始基可行解',
                algorithm_step3: '<strong>第三步：</strong>檢查最優性條件（目標函數行係數）',
                algorithm_step4: '<strong>第四步：</strong>若未達最優，選擇進入變數和離開變數',
                algorithm_step5: '<strong>第五步：</strong>執行樞軸運算，更新單形表',
                algorithm_step6: '<strong>重複步驟3-5</strong>直到達到最優解',
                instructions_title: '📖 詳細使用說明',
                instruction1: '<span class="highlight">目標函數設定</span>：輸入目標函數的係數，用逗號分隔。例如最大化利潤 z = 800x₁ + 1200x₂ 應輸入 <code>800,1200</code>',
                instruction2: '<span class="highlight">約束條件格式</span>：每行輸入一個約束條件，格式為 <code>係數1,係數2,運算符,常數</code>。例如 4x₁ + 6x₂ ≤ 2400 應輸入 <code>4,6,<=,2400</code>',
                instruction3: '<span class="highlight">支持運算符</span>：<code>&lt;=</code> (小於等於), <code>=</code> (等於), <code>&gt;=</code> (大於等於)',
                instruction4: '<span class="highlight">求解過程</span>：點擊"求解"按鈕後，系統將自動計算並顯示初始單形表',
                instruction5: '<span class="highlight">逐步演示</span>：使用"下一步"按鈕查看單形法的每一步計算過程',
                instruction6: '<span class="highlight">視覺化元素</span>：表格中不同顏色標示不同類型的變數和操作',
                instruction7: '<span class="highlight">進度追蹤</span>：頂部進度條顯示當前求解進度',
                footer_title: '🎓 線性規劃單形法可視化教學工具',
                footer_description: '本工具專為線性規劃教學設計，幫助學生理解單形法的計算原理和實際應用。適用於運籌學、管理科學、工業工程等相關課程的教學與自學。',
                footer_tip: '💡 提示：建議配合教科書內容使用，深入理解',
                error: '錯誤',
                invalid_objective: '請輸入有效的目標函數係數（例如：800,1200）。',
                invalid_constraints: '請輸入至少一個有效的約束條件（格式：係數1,係數2,運算符,常數）。',
                initial_tableau: '初始單形表已建立，準備進行最優性檢查。',
                feasible_region: '可行區域',
                optimal_solution_label: '最優解',
                shadow_prices: '影價',
                range_analysis: '範圍分析',
                infeasible: '問題無可行解。',
                unbounded: '問題無界，無法找到有限的最優解。',
                too_many_iterations: '迭代次數過多，可能存在退化或無解問題。',
                iteration_description: '迭代 {iteration}：選擇進入變量 {entering}，離開變量 {leaving}，樞軸元素位於第 {row} 行，第 {col} 列。',
                optimal_reached: '已達到最優解，計算完成。'
            },
            en: {
                title: '🎯 Linear Programming Simplex Method Visualization Tool',
                subtitle: 'This tool uses the Simplex Method to solve linear programming problems and provides a complete visualization of the calculation process. Suitable for solving and teaching real business problems such as production planning, resource allocation, and profit maximization.',
                problem_input: 'Problem Input',
                objective_type: '🎯 Objective Function Type',
                maximize: 'Maximize',
                minimize: 'Minimize',
                objective_coeffs: '💰 Objective Function Coefficients (comma-separated, e.g.: 800,1200)',
                constraints: '⚖️ Constraints (one per line, format: coeff1,coeff2,operator,constant)',
                solve: '🚀 Solve Problem',
                calculation_control: 'Calculation Control',
                current_step: 'Current Step:',
                previous: '⬅️ Previous Step',
                next: 'Next Step ➡️',
                reset: '🔄 Reset',
                step_explanation: 'Step Explanation',
                initial_description: 'Click the "Solve" button to start calculation. After solving, use the "Next Step" button to view each step of the Simplex Method.',
                optimal_solution: '🏭 Optimal Solution (Production Quantity)',
                max_profit: '💰 Maximum Profit',
                currency: 'Million TWD',
                variable_x1: '5nm Chips = <span id="x1">0</span> units',
                variable_x2: '3nm Chips = <span id="x2">0</span> units',
                tableau_process: 'Tableau Calculation Process',
                pivot_element: 'Pivot Element',
                basic_variables: 'Basic Variables',
                entering_variable: 'Entering Variable',
                input_prompt: 'Enter the problem and click the "Solve" button to display the calculation process here.',
                sensitivity_analysis: 'Sensitivity Analysis',
                shadow_prices: 'Shadow Prices',
                range_analysis: 'Range Analysis',
                case_title: '🏢 Case Study: TSMC Chip Production Planning',
                case_description: 'This tool uses TSMC chip production as an example to demonstrate the application of linear programming in real-world manufacturing. Assume TSMC needs to determine the optimal production configuration for 5nm and 3nm chips to maximize profit.',
                problem_setup: '📊 Problem Setup',
                decision_variables: '<strong>Decision Variables:</strong> x₁ = 5nm chip production quantity, x₂ = 3nm chip production quantity',
                objective_function: '<strong>Objective Function:</strong> Maximize profit = 800x₁ + 1200x₂ (Million TWD)',
                constraints_title: '<strong>Constraints:</strong>',
                constraint1: 'Equipment time constraint: 4x₁ + 6x₂ ≤ 2400 (hours)',
                constraint2: 'Material constraint: 2x₁ + 2x₂ ≤ 800 (units)',
                constraint3: 'Technician constraint: x₁ + 3x₂ ≤ 900 (man-hours)',
                constraint4: '5nm capacity limit: x₁ ≤ 300 (units)',
                constraint5: '3nm capacity limit: x₂ ≤ 250 (units)',
                learning_objectives: '🎯 Learning Objectives',
                learning1: 'Understand the conversion of linear programming problems to standard form',
                learning2: 'Master the computational steps and pivot operations of the Simplex Method',
                learning3: 'Learn to interpret the data in the simplex tableau',
                learning4: 'Understand the concepts of basic and non-basic variables',
                learning5: 'Master optimality testing and solution determination',
                algorithm_title: '🧮 Simplex Method Algorithm Explanation',
                algorithm_description: 'The Simplex Method is a classic algorithm for solving linear programming problems, proposed by George Dantzig in 1947. It systematically moves to adjacent basic feasible solutions, improving the objective function value until the optimal solution is found.',
                algorithm_step1: '<strong>Step 1:</strong> Convert the problem to standard form, adding slack variables',
                algorithm_step2: '<strong>Step 2:</strong> Construct the initial simplex tableau and find the initial basic feasible solution',
                algorithm_step3: '<strong>Step 3:</strong> Check optimality conditions (objective function row coefficients)',
                algorithm_step4: '<strong>Step 4:</strong> If not optimal, select entering and leaving variables',
                algorithm_step5: '<strong>Step 5:</strong> Perform pivot operations to update the tableau',
                algorithm_step6: '<strong>Repeat Steps 3-5</strong> until the optimal solution is reached',
                instructions_title: '📖 Detailed Usage Instructions',
                instruction1: '<span class="highlight">Objective Function Setup</span>: Enter the coefficients of the objective function, separated by commas. For example, to maximize profit z = 800x₁ + 1200x₂, enter <code>800,1200</code>',
                instruction2: '<span class="highlight">Constraint Format</span>: Enter one constraint per line in the format <code>coeff1,coeff2,operator,constant</code>. For example, 4x₁ + 6x₂ ≤ 2400 should be entered as <code>4,6,<=,2400</code>',
                instruction3: '<span class="highlight">Supported Operators</span>: <code>&lt;=</code> (less than or equal), <code>=</code> (equal), <code>&gt;=</code> (greater than or equal)',
                instruction4: '<span class="highlight">Solution Process</span>: Click the "Solve" button to automatically calculate and display the initial simplex tableau',
                instruction5: '<span class="highlight">Step-by-Step Demonstration</span>: Use the "Next Step" button to view each step of the Simplex Method',
                instruction6: '<span class="highlight">Visualization Elements</span>: Different colors in the tableau indicate different types of variables and operations',
                instruction7: '<span class="highlight">Progress Tracking</span>: The top progress bar shows the current solving progress',
                footer_title: '🎓 Linear Programming Simplex Method Visualization Tool',
                footer_description: 'This tool is designed for linear programming education, helping students understand the computational principles and practical applications of the Simplex Method. Suitable for courses in operations research, management science, and industrial engineering.',
                footer_tip: '💡 Tip: Use with textbook content for a deeper understanding',
                error: 'Error',
                invalid_objective: 'Please enter valid objective function coefficients (e.g., 800,1200).',
                invalid_constraints: 'Please enter at least one valid constraint (format: coeff1,coeff2,operator,constant).',
                initial_tableau: 'Initial simplex tableau constructed, ready for optimality check.',
                feasible_region: 'Feasible Region',
                optimal_solution_label: 'Optimal Solution',
                shadow_prices: 'Shadow Prices',
                range_analysis: 'Range Analysis',
                infeasible: 'The problem is infeasible.',
                unbounded: 'The problem is unbounded, no finite optimal solution exists.',
                too_many_iterations: 'Too many iterations, possible degeneracy or no solution.',
                iteration_description: 'Iteration {iteration}: Selected entering variable {entering}, leaving variable {leaving}, pivot element at row {row}, column {col}.',
                optimal_reached: 'Optimal solution reached, calculation completed.'
            }
        };

        let currentLanguage = 'zh';
        let tableauHistory = [];
        let currentStep = 0;
        let basisVariables = [];
        let constraintsData = [];
        let objectiveCoefficients = [];
        let chart = null;
        const BIG_M = 1000000;

        // 初始化語言
        function updateLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('[data-key]').forEach(el => {
                const key = el.getAttribute('data-key');
                if (translations[lang][key]) {
                    if (el.tagName === 'OPTION') {
                        el.textContent = translations[lang][key];
                    } else if (el.id === 'step-description') {
                        // 保持動態步驟描述
                    } else {
                        el.innerHTML = translations[lang][key];
                    }
                }
            });
            // 更新樞軸元素的標籤
            document.querySelectorAll('.pivot').forEach(el => {
                el.setAttribute('data-pivot-label', translations[lang].pivot_element || '🎯 Pivot');
            });
            // 重新渲染表格和圖表以更新語言
            if (tableauHistory.length > 0) {
                updateUI();
            }
        }

        // 顯示錯誤訊息
        function displayError(message) {
            const container = document.getElementById('tableau-container');
            container.innerHTML = `<div class="error-message">${message}</div>`;
            document.getElementById('solution-variables').innerHTML = '<div class="variable">' + 
                (translations[currentLanguage].not_optimal || '尚未達到最優解') + '</div>';
            document.getElementById('optimal-value').textContent = '0';
            document.getElementById('shadow-prices').innerHTML = '';
            document.getElementById('range-analysis').innerHTML = '';
            if (chart) {
                chart.destroy();
                chart = null;
            }
        }

        // 綁定按鈕事件
        document.getElementById('solve-btn').addEventListener('click', solveProblem);
        document.getElementById('next-btn').addEventListener('click', showNextStep);
        document.getElementById('prev-btn').addEventListener('click', showPreviousStep);
        document.getElementById('reset-btn').addEventListener('click', reset);

        function solveProblem() {
            // 重置狀態
            tableauHistory = [];
            currentStep = 0;
            basisVariables = [];
            if (chart) {
                chart.destroy();
                chart = null;
            }

            // 解析輸入
            const objectiveType = document.getElementById('objective').value;
            const objectiveInput = document.getElementById('function').value;
            const constraintsInput = document.getElementById('constraints').value;

            // 驗證目標函數
            objectiveCoefficients = objectiveInput.split(',')
                .map(x => parseFloat(x.trim()))
                .filter(x => !isNaN(x));
            if (objectiveCoefficients.length < 1) {
                displayError(translations[currentLanguage].invalid_objective);
                return;
            }

            // 解析約束條件
            constraintsData = constraintsInput.split('\n')
                .map(line => line.trim())
                .filter(line => line !== '')
                .map(line => {
                    const parts = line.split(',');
                    if (parts.length < 3) return null;
                    const coefficients = parts.slice(0, -2)
                        .map(x => parseFloat(x.trim()))
                        .filter(x => !isNaN(x));
                    const operator = parts[parts.length - 2].trim();
                    const rhs = parseFloat(parts[parts.length - 1]);
                    if (coefficients.length !== objectiveCoefficients.length || !['<=', '=', '>='].includes(operator) || isNaN(rhs) || rhs < 0) {
                        return null;
                    }
                    return { coefficients, operator, rhs };
                })
                .filter(c => c !== null);

            if (constraintsData.length === 0) {
                displayError(translations[currentLanguage].invalid_constraints);
                return;
            }

            // 初始化單形表
            try {
                const tableau = initializeTableauBigM(objectiveCoefficients, constraintsData, objectiveType);
                tableauHistory.push({
                    tableau: JSON.parse(JSON.stringify(tableau.tableau)),
                    basis: [...tableau.basis],
                    description: translations[currentLanguage].initial_tableau,
                    pivotRow: -1,
                    pivotCol: -1
                });

                // 執行單形法
                runSimplex(tableau, objectiveType);

                // 顯示第一步
                currentStep = 0;
                updateUI();
                document.getElementById('next-btn').disabled = tableauHistory.length <= 1;
                document.getElementById('prev-btn').disabled = true;
            } catch (e) {
                displayError(`${translations[currentLanguage].error}：${e.message}`);
            }
        }

        function initializeTableauBigM(objective, constraints, type) {
            const numVars = objective.length;
            const numConstraints = constraints.length;
            let numArtificial = 0;
            constraints.forEach(c => {
                if (c.operator === '>=' || c.operator === '=') numArtificial++;
            });
            const numSlack = constraints.filter(c => c.operator === '<=' || c.operator === '>=').length;
            const tableau = [];
            const basis = [];
            let artificialIndex = numVars + numSlack;

            // 添加約束條件行
            constraints.forEach((constraint, i) => {
                const row = new Array(numVars + numSlack + numArtificial + 1).fill(0);
                constraint.coefficients.forEach((coeff, j) => {
                    row[j] = coeff;
                });
                if (constraint.operator === '<=') {
                    row[numVars + i] = 1; // 鬆弛變量
                    basis.push(numVars + i);
                } else if (constraint.operator === '>=') {
                    row[numVars + i] = -1; // 剩餘變量
                    row[artificialIndex] = 1; // 人工變量
                    basis.push(artificialIndex);
                    artificialIndex++;
                } else if (constraint.operator === '=') {
                    row[artificialIndex] = 1; // 人工變量
                    basis.push(artificialIndex);
                    artificialIndex++;
                }
                row[row.length - 1] = constraint.rhs;
                tableau.push(row);
            });

            // 添加目標函數行
            const objRow = new Array(numVars + numSlack + numArtificial + 1).fill(0);
            objective.forEach((coeff, i) => {
                objRow[i] = type === 'max' ? -coeff : coeff;
            });
            for (let i = 0; i < numArtificial; i++) {
                objRow[numVars + numSlack + i] = type === 'max' ? -BIG_M : BIG_M;
            }
            // Big M 方法：將人工變量的係數加到目標函數行
            for (let i = 0; i < numConstraints; i++) {
                if (constraints[i].operator === '>=' || constraints[i].operator === '=') {
                    const artificialIdx = numVars + numSlack + basis[i] - numVars - numSlack;
                    for (let j = 0; j < tableau[0].length; j++) {
                        objRow[j] -= (type === 'max' ? BIG_M : -BIG_M) * tableau[i][j];
                    }
                }
            }
            tableau.push(objRow);

            return { tableau, basis };
        }

        function runSimplex(tableauObj, objectiveType) {
            let { tableau, basis } = tableauObj;
            let iteration = 0;
            const maxIterations = 100;

            while (iteration < maxIterations) {
                const objRow = tableau[tableau.length - 1];
                const pivotCol = objectiveType === 'max'
                    ? objRow.slice(0, -1).reduce((minIdx, val, idx) => val < objRow[minIdx] ? idx : minIdx, 0)
                    : objRow.slice(0, -1).reduce((maxIdx, val, idx) => val > objRow[maxIdx] ? idx : maxIdx, 0);

                if ((objectiveType === 'max' && objRow[pivotCol] >= -1e-10) || 
                    (objectiveType === 'min' && objRow[pivotCol] <= 1e-10)) {
                    // 檢查人工變量是否為零
                    const numVars = objectiveCoefficients.length;
                    const numSlack = constraintsData.filter(c => c.operator === '<=' || c.operator === '>=').length;
                    const artificialStart = numVars + numSlack;
                    for (let i = 0; i < tableau.length - 1; i++) {
                        if (basis[i] >= artificialStart && Math.abs(tableau[i][tableau[0].length - 1]) > 1e-10) {
                            throw new Error(translations[currentLanguage].infeasible);
                        }
                    }
                    tableauHistory.push({
                        tableau: JSON.parse(JSON.stringify(tableau)),
                        basis: [...basis],
                        description: translations[currentLanguage].optimal_reached,
                        pivotRow: -1,
                        pivotCol: -1
                    });
                    break;
                }

                // 最小比率測試
                let minRatio = Infinity;
                let pivotRow = -1;
                for (let i = 0; i < tableau.length - 1; i++) {
                    if (tableau[i][pivotCol] > 1e-10) {
                        const ratio = tableau[i][tableau[0].length - 1] / tableau[i][pivotCol];
                        if (ratio < minRatio && ratio >= -1e-10) {
                            minRatio = ratio;
                            pivotRow = i;
                        }
                    }
                }

                if (pivotRow === -1) {
                    throw new Error(translations[currentLanguage].unbounded);
                }

                // 執行樞軸運算
                const pivotValue = tableau[pivotRow][pivotCol];
                for (let j = 0; j < tableau[0].length; j++) {
                    tableau[pivotRow][j] /= pivotValue;
                }

                for (let i = 0; i < tableau.length; i++) {
                    if (i !== pivotRow) {
                        const factor = tableau[i][pivotCol];
                        for (let j = 0; j < tableau[0].length; j++) {
                            tableau[i][j] -= factor * tableau[pivotRow][j];
                        }
                    }
                }

                // 更新基變量
                basis[pivotRow] = pivotCol;

                // 記錄步驟
                tableauHistory.push({
                    tableau: JSON.parse(JSON.stringify(tableau)),
                    basis: [...basis],
                    description: translations[currentLanguage].iteration_description
                        .replace('{iteration}', iteration + 1)
                        .replace('{entering}', `x${pivotCol + 1}`)
                        .replace('{leaving}', `x${basis[pivotRow] + 1}`)
                        .replace('{row}', pivotRow + 1)
                        .replace('{col}', pivotCol + 1),
                    pivotRow,
                    pivotCol
                });

                iteration++;
            }

            if (iteration >= maxIterations) {
                throw new Error(translations[currentLanguage].too_many_iterations);
            }
        }

        function showNextStep() {
            if (currentStep < tableauHistory.length - 1) {
                currentStep++;
                updateUI();
            }
        }

        function showPreviousStep() {
            if (currentStep > 0) {
                currentStep--;
                updateUI();
            }
        }

        function reset() {
            tableauHistory = [];
            currentStep = 0;
            basisVariables = [];
            document.getElementById('tableau-container').innerHTML = `<p class="step-info">${translations[currentLanguage].input_prompt}</p>`;
            document.getElementById('step-description').textContent = translations[currentLanguage].initial_description;
            document.getElementById('step-counter').textContent = '0 / 0';
            document.getElementById('progress-fill').style.width = '0%';
            document.getElementById('next-btn').disabled = true;
            document.getElementById('prev-btn').disabled = true;
            document.getElementById('solution-variables').innerHTML = `
                <div class="variable">${translations[currentLanguage].variable_x1}</div>
                <div class="variable">${translations[currentLanguage].variable_x2}</div>
            `;
            document.getElementById('optimal-value').textContent = '0';
            document.getElementById('shadow-prices').innerHTML = '';
            document.getElementById('range-analysis').innerHTML = '';
            if (chart) {
                chart.destroy();
                chart = null;
            }
        }

        function updateUI() {
            const step = tableauHistory[currentStep];
            if (!step) return;

            // 更新單形表
            renderTableau(step.tableau, step.basis, step.pivotRow, step.pivotCol);

            // 更新步驟說明
            document.getElementById('step-description').textContent = step.description;

            // 更新步驟計數器和進度條
            document.getElementById('step-counter').textContent = `${currentStep + 1} / ${tableauHistory.length}`;
            const progress = tableauHistory.length > 1 ? (currentStep / (tableauHistory.length - 1)) * 100 : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;

            // 更新按鈕狀態
            document.getElementById('next-btn').disabled = currentStep >= tableauHistory.length - 1;
            document.getElementById('prev-btn').disabled = currentStep <= 0;

            // 更新解決方案
            if (currentStep === tableauHistory.length - 1) {
                const solution = extractSolution(step.tableau, step.basis);
                document.getElementById('solution-variables').innerHTML = solution.variables
                    .map((val, i) => `<div class="variable">x${i + 1} = <span id="x${i + 1}">${val.toFixed(2)}</span> ${translations[currentLanguage][`variable_x${i + 1}`].split('=')[1].trim()}</div>`)
                    .join('');
                document.getElementById('optimal-value').textContent = solution.optimalValue.toFixed(2);

                // 繪製可行區域
                if (objectiveCoefficients.length === 2) {
//                    drawFeasibleRegion(solution.variables[0], solution.variables[1]);
                }

                // 敏感性分析
                performSensitivityAnalysis(step.tableau, step.basis);
            } else {
                document.getElementById('solution-variables').innerHTML = '<div class="variable">' + 
                    (translations[currentLanguage].not_optimal || '尚未達到最優解') + '</div>';
                document.getElementById('optimal-value').textContent = '0';
                document.getElementById('shadow-prices').innerHTML = '';
                document.getElementById('range-analysis').innerHTML = '';
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
            }
        }

        function renderTableau(tableau, basis, pivotRow, pivotCol) {
            const container = document.getElementById('tableau-container');
            const numVars = objectiveCoefficients.length;
            const numSlack = constraintsData.filter(c => c.operator === '<=' || c.operator === '>=').length;
            const numArtificial = constraintsData.filter(c => c.operator === '>=' || c.operator === '=').length;
            let html = '<table><thead><tr>';

            // 生成表頭
            for (let i = 0; i < numVars; i++) {
                html += `<th>x${i + 1}</th>`;
            }
            for (let i = 0; i < numSlack; i++) {
                html += `<th>s${i + 1}</th>`;
            }
            for (let i = 0; i < numArtificial; i++) {
                html += `<th>a${i + 1}</th>`;
            }
            html += '<th>RHS</th></tr></thead><tbody>';

            // 生成表格內容
            tableau.forEach((row, rowIndex) => {
                html += '<tr>';
                row.forEach((cell, colIndex) => {
                    let cellClass = '';
                    if (rowIndex < tableau.length - 1 && basis[rowIndex] === colIndex) {
                        cellClass = 'basis';
                    }
                    if (rowIndex === tableau.length - 1 && colIndex < row.length - 1 && 
                        ((document.getElementById('objective').value === 'max' && cell < -1e-10) || 
                         (document.getElementById('objective').value === 'min' && cell > 1e-10))) {
                        cellClass = 'entering';
                    }
                    if (rowIndex === pivotRow && colIndex === pivotCol) {
                        cellClass = 'pivot';
                    }
                    const displayValue = Math.abs(cell) > 1e5 || Math.abs(cell) < 1e-10 ? cell.toFixed(2) : cell.toFixed(4);
                    html += `<td class="${cellClass}" ${cellClass === 'pivot' ? `data-pivot-label="${translations[currentLanguage].pivot_element}"` : ''}>${displayValue}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function extractSolution(tableau, basis) {
            const numVars = objectiveCoefficients.length;
            const variables = Array(numVars).fill(0);
            basis.forEach((varIdx, rowIdx) => {
                if (varIdx < numVars) {
                    variables[varIdx] = tableau[rowIdx][tableau[0].length - 1];
                }
            });
            const optimalValue = document.getElementById('objective').value === 'max' 
                ? tableau[tableau.length - 1][tableau[0].length - 1]
                : -tableau[tableau.length - 1][tableau[0].length - 1];
            return { variables, optimalValue };
        }

        function drawFeasibleRegion(optimalX1, optimalX2) {
            if (objectiveCoefficients.length !== 2) {
                document.getElementById('feasible-region').style.display = 'none';
                return;
            }
            document.getElementById('feasible-region').style.display = 'block';

            const ctx = document.getElementById('feasible-region').getContext('2d');
            if (chart) chart.destroy();

            const points = calculateFeasiblePoints();
            const maxX = Math.max(...points.map(p => p.x), optimalX1, 300) * 1.2;
            const maxY = Math.max(...points.map(p => p.y), optimalX2, 250) * 1.2;

            // 繪製約束線
            const constraintDatasets = constraintsData.map((c, i) => {
                const points = [];
                if (c.coefficients[0] !== 0) {
                    points.push({ x: 0, y: c.rhs / c.coefficients[1] });
                    points.push({ x: c.rhs / c.coefficients[0], y: 0 });
                } else {
                    points.push({ x: 0, y: c.rhs / c.coefficients[1] });
                    points.push({ x: maxX, y: c.rhs / c.coefficients[1] });
                }
                return {
                    label: `${translations[currentLanguage][`constraint${i+1}`] || `Constraint ${i+1}`}`,
                    data: points,
                    borderColor: `hsl(${i * 60}, 70%, 50%)`,
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    showLine: true
                };
            });

            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: translations[currentLanguage].feasible_region,
                            data: points,
                            backgroundColor: 'rgba(46, 204, 113, 0.3)',
                            borderColor: 'rgba(46, 204, 113, 1)',
                            fill: true,
                            pointRadius: 0,
                            showLine: true,
                            tension: 0
                        },
                        {
                            label: translations[currentLanguage].optimal_solution_label,
                            data: [{ x: optimalX1, y: optimalX2 }],
                            backgroundColor: 'rgba(231, 76, 60, 1)',
                            pointRadius: 8
                        },
                        ...constraintDatasets
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'x₁' },
                            min: 0,
                            max: maxX,
                            ticks: { stepSize: Math.ceil(maxX / 10) }
                        },
                        y: {
                            title: { display: true, text: 'x₂' },
                            min: 0,
                            max: maxY,
                            ticks: { stepSize: Math.ceil(maxY / 10) }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        function calculateFeasiblePoints() {
            const points = [];
            const constraints = constraintsData.map(c => ({
                a: c.coefficients[0],
                b: c.coefficients[1],
                rhs: c.rhs,
                operator: c.operator
            }));

            // 添加 x₁ ≥ 0, x₂ ≥ 0
            constraints.push({ a: 1, b: 0, rhs: 0, operator: '>=' });
            constraints.push({ a: 0, b: 1, rhs: 0, operator: '>=' });

            // 計算所有約束的交點
            const intersections = [];
            for (let i = 0; i < constraints.length; i++) {
                for (let j = i + 1; j < constraints.length; j++) {
                    const c1 = constraints[i];
                    const c2 = constraints[j];
                    const det = c1.a * c2.b - c1.b * c2.a;
                    if (Math.abs(det) > 1e-10) {
                        const x = (c1.b * c2.rhs - c2.b * c1.rhs) / det;
                        const y = (c2.a * c1.rhs - c1.a * c2.rhs) / det;
                        if (isPointFeasible(x, y, constraints)) {
                            intersections.push({ x, y });
                        }
                    }
                }
            }

            // 排序頂點形成凸多邊形
            if (intersections.length > 0) {
                const centerX = intersections.reduce((sum, p) => sum + p.x, 0) / intersections.length;
                const centerY = intersections.reduce((sum, p) => sum + p.y, 0) / intersections.length;
                intersections.sort((a, b) => {
                    const angleA = Math.atan2(a.y - centerY, a.x - centerX);
                    const angleB = Math.atan2(b.y - centerY, b.x - centerX);
                    return angleA - angleB;
                });
                return intersections;
            }
            return [{ x: 0, y: 0 }]; // 預設點
        }

        function isPointFeasible(x, y, constraints) {
            return constraints.every(c => {
                const value = c.a * x + c.b * y;
                if (c.operator === '<=') return value <= c.rhs + 1e-10;
                if (c.operator === '=') return Math.abs(value - c.rhs) < 1e-10;
                if (c.operator === '>=') return value >= c.rhs - 1e-10;
                return true;
            });
        }

        function performSensitivityAnalysis(tableau, basis) {
            const numVars = objectiveCoefficients.length;
            const numSlack = constraintsData.filter(c => c.operator === '<=' || c.operator === '>=').length;
            const objRow = tableau[tableau.length - 1];

            // 影價
            const shadowPrices = [];
            for (let i = 0; i < numSlack; i++) {
                const slackIndex = numVars + i;
                if (basis.includes(slackIndex)) {
                    shadowPrices.push(-objRow[slackIndex]);
                } else {
                    shadowPrices.push(0);
                }
            }

            // 範圍分析（目標函數係數）
            const rangeAnalysis = [];
            for (let i = 0; i < numVars; i++) {
                let minChange = -Infinity;
                let maxChange = Infinity;
                for (let j = 0; j < tableau.length - 1; j++) {
                    if (basis[j] !== i && tableau[j][i] !== 0) {
                        const ratio = -objRow[i] / tableau[j][i];
                        if (tableau[j][i] > 0) {
                            maxChange = Math.min(maxChange, ratio);
                        } else if (tableau[j][i] < 0) {
                            minChange = Math.max(minChange, ratio);
                        }
                    }
                }
                rangeAnalysis.push({
                    variable: `x${i + 1}`,
                    min: objectiveCoefficients[i] + minChange,
                    max: objectiveCoefficients[i] + maxChange
                });
            }

            // 右邊常數範圍
            const rhsRanges = [];
            for (let i = 0; i < tableau.length - 1; i++) {
                let minRHS = -Infinity;
                let maxRHS = Infinity;
                for (let j = 0; j < tableau[0].length - 1; j++) {
                    if (tableau[i][j] !== 0 && !basis.includes(j)) {
                        const ratio = -tableau[i][tableau[0].length - 1] / tableau[i][j];
                        if (tableau[i][j] > 0) {
                            minRHS = Math.max(minRHS, ratio);
                        } else if (tableau[i][j] < 0) {
                            maxRHS = Math.min(maxRHS, ratio);
                        }
                    }
                }
                rhsRanges.push({
                    constraint: i + 1,
                    min: tableau[i][tableau[0].length - 1] + minRHS,
                    max: tableau[i][tableau[0].length - 1] + maxRHS
                });
            }

            // 顯示結果
            document.getElementById('shadow-prices').innerHTML = `
                <p>${translations[currentLanguage].shadow_prices}:<br>
                ${shadowPrices.map((p, i) => `${translations[currentLanguage].constraint}${i + 1}: ${p.toFixed(2)}`).join('<br>')}
                </p>`;
// 顯示範圍分析結果
            document.getElementById('range-analysis').innerHTML = `
                <p>${translations[currentLanguage].range_analysis}:<br>
                <strong>${translations[currentLanguage].objective_function}:</strong><br>
                ${rangeAnalysis.map(r => `${r.variable}: [${r.min.toFixed(2)}, ${r.max.toFixed(2)}]`).join('<br>')}
                <br><strong>${translations[currentLanguage].constraints_title}:</strong><br>
                ${rhsRanges.map(r => `${translations[currentLanguage][`constraint${r.constraint}`] || `Constraint ${r.constraint}`}: [${r.min.toFixed(2)}, ${r.max.toFixed(2)}]`).join('<br>')}
                </p>`;
        }

        // 語言切換事件
        document.getElementById('language').addEventListener('change', function() {
            updateLanguage(this.value);
        });

        // 初始化頁面時設置語言
        document.addEventListener('DOMContentLoaded', () => {
            updateLanguage('zh'); // 預設為中文
            reset(); // 初始化頁面狀態
        });
    </script>
</body>
</html>