<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‡å­ç©¿éš§ Â· 3D ç›¸ç©ºé–“ Â· ç„¡é®æ“‹ç‰ˆ</title>
    <!-- MathJax ç²¾ç°¡å…¬å¼ -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script" async></script>
    <!-- Three.js æ ¸å¿ƒèˆ‡è¼”åŠ© -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif; background-color: #0a0f1e; color: white; }
        
        /* é ‚éƒ¨æ¥µç°¡æ¨™é¡Œ */
        #title-bar {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 20, 35, 0.6);
            backdrop-filter: blur(8px);
            padding: 0.5rem 1.8rem;
            border-radius: 40px;
            border: 1px solid rgba(80, 160, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 20;
            font-size: 1.3rem;
            font-weight: 400;
            letter-spacing: 1px;
            white-space: nowrap;
            color: #e0f0ff;
        }
        #title-bar span {
            color: #ffaa44; 
            font-weight: 600;
        }

        /* åº•éƒ¨è³‡è¨Šæ©«æ¢ â€” å®Œå…¨ä¸é®æ“‹ä¸»è¦è¦–é‡ */
        #info-footer {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background: rgba(5, 15, 25, 0.7);
            backdrop-filter: blur(12px);
            border-radius: 60px;
            padding: 0.7rem 2rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #2f5f8a;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            z-index: 30;
            font-size: 0.95rem;
            color: #cce4ff;
            gap: 10px;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°ç•«å¸ƒï¼Œä½†å…§éƒ¨æ–‡å­—ä¸å¯é¸ */
        }
        #info-footer * {
            pointer-events: none;
        }
        .footer-section {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-right: 15px;
        }
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 4px;
            background: #ffaa44;
            box-shadow: 0 0 8px currentColor;
        }
        .dot-blue { background: #3a6ea5; }
        .dot-red { background: #ff6666; }
        .formula-tiny {
            font-size: 0.9rem;
            background: rgba(0, 30, 50, 0.5);
            padding: 0.2rem 1rem;
            border-radius: 30px;
            border-left: 2px solid #5f9eff;
        }
        .formula-tiny mjx-container {
            font-size: 1rem;
        }
        #status-chip {
            background: #1e3a5f;
            border-radius: 30px;
            padding: 0.2rem 1.2rem;
            color: #aad0ff;
            border: 1px solid #3f8ec0;
            font-weight: 400;
        }

        /* å³ä¸Šè§’å°ç‹€æ…‹æ¨™ç±¤ (åŸæœ¬çš„ç§»åˆ°é€™è£¡) */
        #energy-tag {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 30, 50, 0.7);
            backdrop-filter: blur(5px);
            border-radius: 40px;
            padding: 0.3rem 1.2rem;
            font-size: 0.9rem;
            border: 1px solid #4f9fdf;
            color: #b0e0ff;
            z-index: 25;
            letter-spacing: 0.5px;
        }

        /* æ§åˆ¶æç¤º (å³ä¸‹) æ¥µå° */
        #control-hint {
            position: absolute;
            bottom: 90px;
            right: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 30px;
            padding: 0.2rem 1rem;
            font-size: 0.8rem;
            color: #bbd5ff;
            backdrop-filter: blur(2px);
            border: 1px solid #336699;
            z-index: 25;
        }

        /* 3D ç©ºé–“ä¸­çš„ CSS2D æ¨™ç±¤å¾®èª¿ â€” æ›´å°ã€åŠé€æ˜ */
        .css2d-label {
            font-size: 14px !important;
            background: rgba(0,0,0,0.5) !important;
            padding: 2px 8px !important;
            border-radius: 16px !important;
            border: 1px solid #4a6c8f !important;
            color: #ddd !important;
            font-weight: 400 !important;
            backdrop-filter: blur(2px);
            white-space: nowrap;
        }
        .neg-label {
            background: rgba(80, 20, 20, 0.7) !important;
            border-color: #b55 !important;
            color: #ffb6b6 !important;
        }
    </style>
</head>
<body>
    <!-- æ¥µç°¡é ‚éƒ¨æ¨™é¡Œ -->
    <div id="title-bar">âš›ï¸ <span>é‡å­ç©¿éš§</span> Â· ç›¸ç©ºé–“ 3D å‹•ç•«</div>

    <!-- å³ä¸Šè§’èƒ½é‡ç‹€æ…‹ -->
    <div id="energy-tag">âš¡ E < Vâ‚€  ç©¿éš§ä¸­</div>

    <!-- åº•éƒ¨è³‡è¨Šæ©«æ¢ (å®Œå…¨ä¸é®æ“‹ä¸»è¦å€åŸŸ) -->
    <div id="info-footer">
        <div class="footer-section">
            <span class="legend-item"><span class="color-dot" style="background:#ffaa44;"></span> æ³¢åŒ… |Ïˆ|Â²</span>
            <span class="legend-item"><span class="color-dot dot-blue"></span> ä½èƒ½å£˜ V(x)</span>
            <span class="legend-item"><span class="color-dot dot-red"></span> ç©¿éš§éƒ¨åˆ†</span>
        </div>
        <div class="footer-section formula-tiny">
            \[
            \psi(x,0) \sim e^{-\alpha(x-x_0)^2/2}e^{ik_0x},\quad V(x)=Ae^{-x^2/(2\sigma^2)}
            \]
        </div>
        <div class="footer-section" id="status-chip">
            ğŸŒ€ è² å€¼å€ = é‡å­å¹²æ¶‰
        </div>
    </div>

    <!-- å³ä¸‹æ“ä½œæç¤º -->
    <div id="control-hint">ğŸ–±ï¸ æ‹–æ›³æ—‹è½‰ Â· æ»¾è¼ªç¸®æ”¾</div>

    <!-- Three.js ç•«å¸ƒå°‡è‡ªå‹•æ’å…¥åˆ° body ä¸­ï¼Œæ­¤è™•ç„¡éœ€é¡å¤–æ¨™ç±¤ -->

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- åˆå§‹åŒ–å ´æ™¯ã€ç›¸æ©Ÿã€æ¸²æŸ“å™¨ (èˆ‡ä¹‹å‰ç›¸åŒï¼Œä½†èª¿æ•´èƒŒæ™¯æ›´ç´”æ·¨) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0f1e);
        scene.fog = new THREE.Fog(0x0a0f1e, 30, 80);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(12, 6, 18);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // CSS2æ¸²æŸ“å™¨ (ç”¨æ–¼ç°¡æ½”æ¨™ç±¤)
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // æ§åˆ¶å™¨
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.enableZoom = true;
        controls.maxPolarAngle = Math.PI / 2;

        // --- å…‰æº ---
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const backLight = new THREE.PointLight(0x446688, 0.8);
        backLight.position.set(-5, 3, -5);
        scene.add(backLight);

        // èƒŒæ™¯æ˜Ÿæ˜Ÿ
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 1000;
        const starPositions = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount; i++) {
            starPositions[i*3] = (Math.random() - 0.5) * 250;
            starPositions[i*3+1] = (Math.random() - 0.5) * 250;
            starPositions[i*3+2] = (Math.random() - 0.5) * 250;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starsMaterial = new THREE.PointsMaterial({color: 0xaaccff, size: 0.18});
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // --- è¼”åŠ©å…ƒç´  (ç²¾ç°¡ï¼Œä¸åŠ å¤§å‹æ¨™ç±¤ï¼Œåªç•™ç´°ç·š) ---
        const gridHelper = new THREE.GridHelper(30, 20, 0x336699, 0x224466);
        gridHelper.position.y = -0.2;
        scene.add(gridHelper);
        // ç°¡å–®åº§æ¨™è»¸ (ä¸åŠ æ–‡å­—ï¼Œåªç”¨é¡è‰²ç·š)
        const axesHelper = new THREE.AxesHelper(8);
        scene.add(axesHelper);

        // æ¥µå°åº§æ¨™æ¨™ç±¤ (é¸æ“‡æ€§åŠ å…¥ï¼Œä½†ä¸æ“‹ç•«é¢ï¼Œå¾ˆå°)
        function createSmallAxisLabel(text, color, pos) {
            const div = document.createElement('div');
            div.textContent = text;
            div.style.color = color;
            div.style.fontSize = '12px';
            div.style.background = 'rgba(20,30,50,0.6)';
            div.style.padding = '2px 6px';
            div.style.borderRadius = '10px';
            div.style.border = '1px solid #3a5f7a';
            const label = new CSS2DObject(div);
            label.position.copy(pos);
            scene.add(label);
        }
        createSmallAxisLabel('x', '#ffaa88', new THREE.Vector3(9, 0.2, 0));
        createSmallAxisLabel('|Ïˆ|Â²', '#88ff88', new THREE.Vector3(0, 5, 0));
        createSmallAxisLabel('p (ç›¸)', '#8888ff', new THREE.Vector3(0, 0.2, 7));

        // --- ä½èƒ½å£˜ (åŠé€æ˜é«˜æ–¯å½¢ç‹€ï¼Œèˆ‡ä¹‹å‰ç›¸åŒ) ---
        const barrierGroup = new THREE.Group();
        const potHeight = 2.5;
        const potSigma = 1.8;
        const slices = 30;
        for (let i = 0; i <= slices; i++) {
            const t = (i / slices) * 2 - 1;
            const xPos = t * 4.5;
            const gauss = Math.exp(- (xPos * xPos) / (2 * potSigma * potSigma));
            const sliceHeight = potHeight * gauss + 0.3;
            const geometry = new THREE.BoxGeometry(0.25, sliceHeight, 2.0);
            const material = new THREE.MeshPhongMaterial({
                color: 0x3a6ea5,
                transparent: true,
                opacity: 0.25,
                emissive: 0x102030,
            });
            const sliceMesh = new THREE.Mesh(geometry, material);
            sliceMesh.position.set(xPos, sliceHeight/2, 0);
            barrierGroup.add(sliceMesh);
        }
        // åŠ ä¸€å€‹æ¥µæ·¡å¤–æ¡†
        const barrierOutline = new THREE.Mesh(
            new THREE.BoxGeometry(7.5, potHeight*1.2, 2.8),
            new THREE.MeshBasicMaterial({ color: 0x5a8ec9, wireframe: true, transparent: true, opacity: 0.1 })
        );
        barrierOutline.position.set(0, potHeight*0.6, 0);
        barrierGroup.add(barrierOutline);
        scene.add(barrierGroup);

        // --- ç²’å­ç³»çµ± (æ³¢åŒ…) ---
        const particleCount = 1800;
        const particlesGeo = new THREE.BufferGeometry();
        const initialPositions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let x = -4.0 + (Math.random() - 0.5) * 2.5;
            let y = Math.abs( (Math.random() * 1.5) * Math.exp(-0.5 * Math.pow((x + 4) / 1.2, 2)) );
            let z = (Math.random() - 0.5) * 2.5;
            if (Math.random() > 0.7) {
                x = -2.5 + Math.random() * 2;
                y = 0.1 + Math.random() * 0.5;
                z = (Math.random() - 0.5) * 3;
            }
            initialPositions[i*3] = x;
            initialPositions[i*3+1] = y * 2.5;
            initialPositions[i*3+2] = z;
            
            colors[i*3] = 1.0;
            colors[i*3+1] = 0.7 + y * 0.3;
            colors[i*3+2] = 0.2;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(initialPositions, 3));
        particlesGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMat = new THREE.PointsMaterial({ 
            size: 0.15, 
            vertexColors: true, 
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);

        // æ ¸å¿ƒç™¼å…‰çƒ (ä»£è¡¨æ³¢åŒ…æ ¸å¿ƒ)
        const coreSpheres = [];
        const sphereMat = new THREE.MeshStandardMaterial({ color: 0xffaa44, emissive: 0x442200 });
        for (let i = 0; i < 5; i++) {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), sphereMat);
            sphere.position.set(-4.0 + i*0.2, 1.2 + i*0.1, 0.2);
            coreSpheres.push(sphere);
            scene.add(sphere);
        }

        // ç©¿éš§ç´…çƒ
        const tunnelSpheres = [];
        for (let i = 0; i < 4; i++) {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.25, 10, 10), new THREE.MeshStandardMaterial({ color: 0xff6666, emissive: 0x330000 }));
            sphere.position.set(2.0, 0.8, -0.5);
            sphere.visible = false;
            tunnelSpheres.push(sphere);
            scene.add(sphere);
        }

        // --- è² å€¼å€è¦–è¦ºæç¤º (åŠé€æ˜ç´…æ–¹å¡Š + å°æ¨™ç±¤) èª¿æ•´æ¨™ç±¤æ¨£å¼--- 
        const negRegionMat = new THREE.MeshPhongMaterial({ color: 0xff3333, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        const negRegion = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.2, 1.8), negRegionMat);
        negRegion.position.set(-1.5, 0.8, 0.5);
        scene.add(negRegion);
        
        const negDiv = document.createElement('div');
        negDiv.textContent = 'å¹²æ¶‰è² å€¼å€';
        negDiv.className = 'css2d-label neg-label';
        const negLabel = new CSS2DObject(negDiv);
        negLabel.position.set(-1.5, 1.6, 0.5);
        scene.add(negLabel);

        // å„²å­˜ç²’å­åˆå§‹ä½ç½®
        const particlePositions = particleSystem.geometry.attributes.position.array;
        const originalX = new Float32Array(particleCount);
        for (let i = 0; i < particleCount; i++) {
            originalX[i] = particlePositions[i*3];
        }

        // --- å‹•ç•«å¾ªç’° (èˆ‡ä¹‹å‰ç›¸åŒï¼Œç¶­æŒå‹•æ…‹) ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() * 0.001;

            const t = elapsedTime * 0.8;
            const phase = (t % (2*Math.PI)) / (2*Math.PI);
            
            for (let i = 0; i < particleCount; i++) {
                let x = originalX[i];
                let baseShift = 0;
                let reflection = false;
                let transmission = false;
                
                if (phase < 0.25) {
                    baseShift = phase * 12;
                } else if (phase < 0.5) {
                    baseShift = 3.0;
                    if (i % 3 === 0) transmission = true;
                    else if (i % 4 === 0) reflection = true;
                } else if (phase < 0.75) {
                    baseShift = 3.0 - (phase - 0.5) * 8;
                    if (i % 3 === 0) transmission = true;
                } else {
                    baseShift = -1.0 + (phase - 0.75) * 8;
                }
                
                let newX;
                if (transmission) {
                    newX = 4.0 + Math.sin(i) * 1.5;
                } else if (reflection) {
                    newX = -4.0 - Math.cos(i) * 1.2;
                } else {
                    newX = originalX[i] + baseShift;
                }
                
                if (newX > 6) newX = 6;
                if (newX < -6) newX = -6;
                
                particlePositions[i*3] = newX;
                
                // é¡è‰²æ ¹æ“šä½ç½®æ”¹è®Š
                if (newX > 2.0) {
                    particlePositions[i*3+1] = particlePositions[i*3+1] * 0.8;
                    colors[i*3] = 1.0; colors[i*3+1] = 0.4; colors[i*3+2] = 0.4;
                } else if (newX < -3.0 && phase > 0.5) {
                    colors[i*3] = 0.3; colors[i*3+1] = 0.6; colors[i*3+2] = 1.0;
                } else {
                    colors[i*3] = 1.0; colors[i*3+1] = 0.8; colors[i*3+2] = 0.2;
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            // æ›´æ–°æ ¸å¿ƒçƒ
            if (coreSpheres.length) {
                let sumX = 0;
                for (let i = 0; i < particleCount; i+=10) {
                    sumX += particlePositions[i*3];
                }
                const avgX = sumX / (particleCount/10);
                coreSpheres[0].position.x = avgX;
                coreSpheres[0].position.y = 1.2;
                for (let j = 1; j < coreSpheres.length; j++) {
                    coreSpheres[j].position.x = avgX + j*0.3 - 0.6;
                    coreSpheres[j].position.y = 1.0 + Math.sin(elapsedTime*2 + j)*0.2;
                }
            }
            
            // ç©¿éš§çƒé¡¯ç¤º
            let anyTransmission = false;
            for (let i = 0; i < particleCount; i+=30) {
                if (particlePositions[i*3] > 2.0) anyTransmission = true;
            }
            tunnelSpheres.forEach((s, idx) => {
                s.visible = anyTransmission;
                if (anyTransmission) {
                    s.position.x = 3.5 + Math.sin(elapsedTime*2 + idx)*0.8;
                    s.position.y = 0.8 + Math.cos(elapsedTime*3 + idx)*0.5;
                    s.position.z = -0.5 + Math.sin(elapsedTime + idx)*1.0;
                }
            });

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);

            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>