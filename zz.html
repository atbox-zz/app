<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>京房八宮卦立方體模型 (數字標記版)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Microsoft YaHei', 'PingFang TC', sans-serif;
            color: #333;
            background-color: #f0f0f0;
        }
        #info-container {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #info-container h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        .control-group {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        #info-container label {
            font-weight: bold;
            margin-right: 10px;
        }
        #info-container select {
            padding: 3px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>

    <div id="info-container">
        <h1>京房八宮卦3D正方立體圖</h1>
        <div class="legend">
            <strong>SRT維爻切分陰陽</strong>
            <div><input type="checkbox" id="s" name="s"><label for="s" style="font-weight:normal;">S切分</label></div>
            <div><input type="checkbox" id="r" name="r"><label for="r" style="font-weight:normal;">R切分</label></div>
            <div><input type="checkbox" id="t" name="t"><label for="t" style="font-weight:normal;">T切分</label></div>
        </div>
        <div class="control-group">
            <label for="sequence-selector">卦序:</label>
            <select id="sequence-selector">
                <option value="none">無</option>
                <option value="shangshi">上世</option>
                <option value="yishi">一世</option>
                <option value="ershi">二世</option>
                <option value="sanshi">三世</option>
                <option value="sishi">四世</option>
                <option value="wushi">五世</option>
                <option value="youhun">遊魂</option>
                <option value="guihun">歸魂</option>
            </select>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, numberGroup;
        const CUBE_SIZE = 10;
        
        // --- 數據定義 ---

        const s = CUBE_SIZE / 2;
        const offset = 2.2; // 調整文字與頂點的距離

        // 卦象在立方體頂點的空間位置 (先天八卦方位)
        const TRIGRAM_POSITIONS = {
            '乾': new THREE.Vector3(s + offset, s + offset, -s - offset), '兑': new THREE.Vector3(s + offset, s + offset, s + offset),
            '離': new THREE.Vector3(s + offset, -s - offset, s + offset), '震': new THREE.Vector3(-s - offset, s + offset, s + offset),
            '巽': new THREE.Vector3(-s - offset, s + offset, -s - offset), '坎': new THREE.Vector3(s + offset, -s - offset, -s - offset),
            '艮': new THREE.Vector3(-s - offset, -s - offset, -s - offset), '坤': new THREE.Vector3(-s - offset, -s - offset, s + offset)
        };
        
        // 根據原圖定義的數字順序
        const SEQUENCES = {
            'shangshi': ['艮', '坤', '震', '巽'],
            'yishi': ['乾', '巽', '艮', '震'],
            'ershi': ['兑', '震', '坤', '坎'],
            'sanshi': ['離', '艮', '巽', '乾'],
            'sishi': ['巽', '乾', '兑', '坤'],
            'wushi': ['坎', '坤', '震', '兑'],
            'youhun': ['艮', '離', '乾', '震'],
            'guihun': ['震', '坎', '艮', '坤']
        };

        // --- 初始化與場景設定 ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 12, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // 創建幾何體與標籤
            createMainCube(CUBE_SIZE);
            createInnerRedSquares(CUBE_SIZE);
            createCenterLines(CUBE_SIZE);
            createTrigramLabels();

            // 創建用於存放數字的羣組
            numberGroup = new THREE.Group();
            scene.add(numberGroup);

            // 設置事件監聽
            document.getElementById('sequence-selector').addEventListener('change', updateNumbers);
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        // --- 繪圖函數 ---

        function createMainCube(size) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const cube = new THREE.LineSegments(edges, lineMaterial);
            scene.add(cube);
        }

        function createInnerRedSquares(size) {
            const s = size / 4;
            const points = [];
            ['x', 'y', 'z'].forEach(axis => {
                for (let i = -1; i <= 1; i += 2) {
                    const p = (a, b) => {
                        const v = {x: 0, y: 0, z: 0};
                        v[axis] = s * 2 * i;
                        const other_axes = Object.keys(v).filter(k => k !== axis);
                        v[other_axes[0]] = a * s;
                        v[other_axes[1]] = b * s;
                        return new THREE.Vector3(v.x, v.y, v.z);
                    };
                    points.push(p(-1, -1), p(1, -1), p(1, -1), p(1, 1), p(1, 1), p(-1, 1), p(-1, 1), p(-1, -1));
                }
            });
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            scene.add(new THREE.LineSegments(geometry, lineMaterial));
        }

        function createCenterLines(size) {
            const s = size / 2;
            const points = [
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, s, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -s, 0),
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, s), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -s),
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(s, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-s, 0, 0)
            ];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            scene.add(new THREE.LineSegments(lineGeometry, lineMaterial));
        }

        function makeTextSprite(message, opts = {}) {
            const { fontsize = 36, fontface = "Arial", textColor = { r: 0, g: 0, b: 0, a: 1.0 } } = opts;
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            canvas.width = metrics.width + 10;
            canvas.height = fontsize + 10;
            context.font = `Bold ${fontsize}px ${fontface}`;
            context.fillStyle = `rgba(${textColor.r}, ${textColor.g}, ${textColor.b}, ${textColor.a})`;
            context.fillText(message, 5, fontsize);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(canvas.width/20, canvas.height/20, 1.0);
            return sprite;
        }

        function createTrigramLabels() {
            for (const [name, pos] of Object.entries(TRIGRAM_POSITIONS)) {
                // 字體縮小，使用 fontsize: 36
                const sprite = makeTextSprite(name, { fontsize: 36 });
                sprite.position.copy(pos);
                scene.add(sprite);
            }
        }
        
        function updateNumbers() {
            // 1. 清除舊的數字
            while(numberGroup.children.length > 0){ 
                numberGroup.remove(numberGroup.children[0]); 
            }

            // 2. 獲取下拉選單的值
            const selectedValue = document.getElementById('sequence-selector').value;
            if (selectedValue === 'none') {
                return; // 如果選擇"無"，則不顯示數字
            }

            // 3. 獲取對應的卦象順序
            const sequence = SEQUENCES[selectedValue];
            
            // 4. 創建並添加新的數字
            sequence.forEach((trigramName, index) => {
                const number = (index + 1).toString();
                const trigramPos = TRIGRAM_POSITIONS[trigramName];
                
                if (trigramPos) {
                    // 數字標籤，用紅色且字體稍小以作區分
                    const numberSprite = makeTextSprite(number, {
                        fontsize: 32,
                        textColor: { r: 200, g: 0, b: 0, a: 1.0 }
                    });
                    
                    // 將數字放在卦象名稱的下方
                    const numberPos = trigramPos.clone();
                    const direction = new THREE.Vector3().copy(trigramPos).normalize();
                    numberPos.add(direction.multiplyScalar(-1.8)); // 沿頂點到中心的反方向移動一點距離

                    numberSprite.position.copy(numberPos);
                    numberGroup.add(numberSprite);
                }
            });
        }
        
        // --- 動畫循環與事件處理 ---
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>