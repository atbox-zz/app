<!doctype html>

<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>3×3 魔術方塊｜互動示意 × 公式速查（含回放與自訂）</title>
  <meta name="description" content="手機友善：上方可拖曳旋轉的 3D 魔方示意；下方提供 CFOP / F2L / OLL / PLL 與群論核心公式；支援公式回放、自訂配色與尺寸。" />
  <style>
    :root{
      --bg:#0b0f14;--fg:#e8f0ff;--muted:#9fb3d1;--card:#0f1724;--accent:#60a5fa;--border:#223046;
      --red:#e11d48;--orange:#f97316;--yellow:#facc15;--green:#16a34a;--blue:#2563eb;--white:#e5e7eb;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Noto Sans TC,"PingFang TC",sans-serif}
    a{color:var(--accent);text-decoration:none}
    .app{display:flex;flex-direction:column;min-height:100vh}
    header{padding:12px 16px;border-bottom:1px solid var(--border);position:sticky;top:0;background:linear-gradient(180deg,rgba(11,15,20,.95),rgba(11,15,20,.75));z-index:20}
    header h1{font-size:17px;margin:0;font-weight:700}
    header .sub{font-size:12px;color:var(--muted);margin-top:4px}.viewer{position:relative;flex:0 0 auto}
.stage{height:46vh;min-height:300px;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--border)}
.hud{position:absolute;left:12px;bottom:12px;display:flex;gap:8px;align-items:center}
.chip{background:rgba(255,255,255,.04);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px;color:var(--muted)}

/* 3D 容器 */
.cube-wrap{perspective:1200px;touch-action:none}
.cube{position:relative;width:var(--cube-size,260px);height:var(--cube-size,260px);transform-style:preserve-3d;transition:transform .15s ease}
.face{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:6px;padding:6px}
.sticker{border-radius:8px;box-shadow:inset 0 0 6px rgba(0,0,0,.35),0 1px 0 rgba(255,255,255,.06)}
.face--F{transform:translateZ(calc(var(--cube-size)/2))}
.face--B{transform:rotateY(180deg) translateZ(calc(var(--cube-size)/2))}
.face--U{transform:rotateX(90deg) translateZ(calc(var(--cube-size)/2))}
.face--D{transform:rotateX(-90deg) translateZ(calc(var(--cube-size)/2))}
.face--R{transform:rotateY(90deg) translateZ(calc(var(--cube-size)/2))}
.face--L{transform:rotateY(-90deg) translateZ(calc(var(--cube-size)/2))}

.panel{flex:1 1 auto;padding:12px;overflow:auto}
.group{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;margin-bottom:12px}
.group h2{font-size:15px;margin:0 0 8px}
.group p{margin:6px 0;color:var(--muted);font-size:13px}
.algo{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;margin:8px 0;border-radius:10px;background:rgba(255,255,255,.02)}
.algo pre{margin:0;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:14px}
.btn{appearance:none;border:1px solid var(--border);background:transparent;padding:8px 10px;border-radius:10px;color:var(--fg);font-size:13px}
.row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
.note{font-size:12px;color:var(--muted)}
.kbd{font-family:ui-monospace,Consolas,monospace;background:rgba(255,255,255,.03);border:1px solid var(--border);padding:2px 6px;border-radius:6px}

footer{padding:20px 12px 40px;color:var(--muted);text-align:center}

/* controls */
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.input,select{background:rgba(255,255,255,.03);border:1px solid var(--border);padding:8px;border-radius:8px;color:var(--fg)}
.small{font-size:13px}

/* highlight current move */
.moves{display:flex;gap:6px;flex-wrap:wrap}
.move{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.02)}
.move.active{background:var(--accent);color:#02102a}

  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>3×3 魔術方塊｜互動示意 × 公式速查（含回放與自訂）</h1>
      <div class="sub">上方示意可拖曳旋轉，下方可選公式並回放；支援配色與尺寸自訂。</div>
    </header>
    
    <section class="viewer">
  <div class="stage">
    <div class="cube-wrap" id="cubeWrap">
      <div class="cube" id="cube" aria-label="可拖曳旋轉的 3D 魔方示意">
        <div class="face face--F" data-face="F"></div>
        <div class="face face--B" data-face="B"></div>
        <div class="face face--U" data-face="U"></div>
        <div class="face face--D" data-face="D"></div>
        <div class="face face--R" data-face="R"></div>
        <div class="face face--L" data-face="L"></div>
      </div>
    </div>
    <div class="hud">
      <span class="chip" id="angleReadout">旋轉：0°, 0°</span>
      <button class="btn" id="resetBtn">重置視角</button>
    </div>
  </div>
</section>

<main class="panel">
  <div class="group">
    <h2>視覺設定（自訂）</h2>
    <div class="controls">
      <label class="small">尺寸：<input id="sizeInput" class="input" type="range" min="160" max="420" value="260" /></label>
      <label class="small">貼紙邊距：<input id="gapInput" class="input" type="range" min="2" max="12" value="6" /></label>
      <label class="small">配色：
        <select id="paletteSelect" class="input">
          <option value="standard">標準（白黃紅橙綠藍）</option>
          <option value="highcontrast">高對比（白 黃 紅 橙 綠 藍）</option>
          <option value="mono">單色（灰階）</option>
        </select>
      </label>
      <button class="btn" id="resetColors">重置配色</button>
    </div>
    <p class="note">調整尺寸與間距會即時反應；配色可選常見預設或單色方便教學。</p>
  </div>

  <div class="group">
    <h2>符號約定（Notation）</h2>
    <p><span class="kbd">R L U D F B</span>：右左上下前後；無撇號＝順時針 90°，<span class="kbd">'</span>＝逆時針 90°，<span class="kbd">2</span>＝180°。</p>
    <div class="row">
      <button class="btn algoBtn" data-algo="R U R' U'">複製 / 播放：觸發器（R U R' U'）</button>
      <button class="btn algoBtn" data-algo="R U R' U R U2 R'">複製 / 播放：OLL 小魚</button>
      <button class="btn algoBtn" data-algo="R2 U R U R' U' R' U' R' U R'">複製 / 播放：PLL（U-perm）</button>
    </div>
  </div>

  <div class="group">
    <h2>公式速查（點選播放）</h2>
    <div class="algo"><pre>F2（F2L 範例）: U R U' R' U' F' U F</pre><button class="btn algoBtn" data-algo="U R U' R' U' F' U F">播放</button></div>
    <div class="algo"><pre>OLL（小魚）: R U R' U R U2 R'</pre><button class="btn algoBtn" data-algo="R U R' U R U2 R'">播放</button></div>
    <div class="algo"><pre>PLL（T-perm）: R U R' F' R U R' U' R' F R2 U' R' U'</pre><button class="btn algoBtn" data-algo="R U R' F' R U R' U' R' F R2 U' R' U'">播放</button></div>
    <p class="note">播放時會在下方顯示移動序列與當前步驟。</p>

    <div style="margin-top:10px">
      <label class="small">自訂序列（空格或逗號分隔）：</label>
      <input id="customAlgo" class="input" placeholder="例如：R U R' U' R' F R2 U'" />
      <div style="margin-top:8px;display:flex;gap:8px"><button class="btn" id="playCustom">播放自訂</button><button class="btn" id="copyCustom">複製序列</button></div>
    </div>

    <div style="margin-top:12px">
      <div id="movesContainer" class="moves"></div>
      <div style="margin-top:8px;display:flex;gap:8px"><button class="btn" id="pauseBtn">暫停</button><button class="btn" id="stopBtn">停止</button><label class="small">速度：<input id="speedRange" type="range" min="200" max="1200" value="600" /></label></div>
    </div>
  </div>

  <div class="group">
    <h2>群論核心（理解用）</h2>
    <div class="algo"><pre>[X, Y] = X Y X⁻¹ Y⁻¹</pre><button class="btn" data-copy="[X, Y] = X Y X^{-1} Y^{-1}">複製</button></div>
    <div class="algo"><pre>Z X Z⁻¹</pre><button class="btn" data-copy="Z X Z^{-1}">複製</button></div>
    <p class="note">換位（commutator）與共軛（conjugate）是設計魔方公式的核心工具。</p>
  </div>

</main>

<footer>
  <div>說明：為教學示意，因此回放以視覺化「全體旋轉 + 顯示步序」為主，非完整方塊狀態模擬；需要完整狀態引擎（可選）我可再加上。</div>
</footer>

  </div>  <script>
    // ----------------- 初始化貼紙 DOM -----------------
    (function buildCube(){
      const faces = {F:'green',B:'blue',U:'white',D:'yellow',R:'red',L:'orange'};
      const palette = {
        standard: {F:'#16a34a',B:'#2563eb',U:'#f8fafc',D:'#facc15',R:'#e11d48',L:'#f97316'},
        highcontrast: {F:'#0ea5a4',B:'#1e3a8a',U:'#ffffff',D:'#ffd166',R:'#ef4444',L:'#fb923c'},
        mono: {F:'#bfc7cf',B:'#9aa6b2',U:'#f3f4f6',D:'#d1d5db',R:'#a3a3a3',L:'#8b8b8b'}
      };
      const cube = document.getElementById('cube');
      cube.innerHTML = '';
      Object.keys(faces).forEach(faceKey=>{
        const face = document.createElement('div'); face.className='face face--'+faceKey; face.dataset.face = faceKey;
        for(let i=0;i<9;i++){ const s = document.createElement('div'); s.className='sticker'; s.dataset.idx = i; face.appendChild(s); }
        cube.appendChild(face);
      });
      // apply default palette
      function applyPalette(name='standard'){ const p = palette[name]; document.querySelectorAll('.face').forEach(f=>{ const key = f.dataset.face; const color = p[key]; Array.from(f.children).forEach(ch=>ch.style.background = color); }); }
      applyPalette('standard');
      // expose for controls
      window._paletteApply = applyPalette;
    })();

    // ----------------- 旋轉互動 -----------------
    (function(){
      const cube = document.getElementById('cube');
      const wrap = document.getElementById('cubeWrap');
      const readout = document.getElementById('angleReadout');
      const resetBtn = document.getElementById('resetBtn');
      let rotX = -18, rotY = -32, scale = 1, dragging=false, lastX=0,lastY=0;
      function render(){ cube.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) scale(${scale})`; readout.textContent = `旋轉：${Math.round(rotX)}°, ${Math.round(rotY)}°`; }
      function onDown(x,y){ dragging=true; lastX=x; lastY=y; }
      function onMove(x,y){ if(!dragging) return; const dx=x-lastX, dy=y-lastY; rotY += dx*0.4; rotX -= dy*0.4; lastX=x; lastY=y; render(); }
      function onUp(){ dragging=false; }
      wrap.addEventListener('mousedown', e=>onDown(e.clientX,e.clientY)); window.addEventListener('mousemove', e=>onMove(e.clientX,e.clientY)); window.addEventListener('mouseup', onUp);
      wrap.addEventListener('touchstart', e=>{ if(e.touches.length===1){ const t=e.touches[0]; onDown(t.clientX,t.clientY);} },{passive:true});
      wrap.addEventListener('touchmove', e=>{ if(e.touches.length===1){ const t=e.touches[0]; onMove(t.clientX,t.clientY);} },{passive:true});
      wrap.addEventListener('touchend', onUp);
      resetBtn.addEventListener('click', ()=>{ rotX=-18; rotY=-32; scale=1; render(); });
      render();
    })();

    // ----------------- 視覺設定 控制 -----------------
    (function(){
      const sizeInput = document.getElementById('sizeInput');
      const gapInput = document.getElementById('gapInput');
      const paletteSelect = document.getElementById('paletteSelect');
      const resetColors = document.getElementById('resetColors');
      const cube = document.getElementById('cube');
      function applySize(v){ document.documentElement.style.setProperty('--cube-size', v+'px'); }
      function applyGap(v){ document.querySelectorAll('.face').forEach(f=>{ const g = v+'px'; f.style.gap = g; f.style.padding = g; }); }
      sizeInput.addEventListener('input', e=>applySize(e.target.value)); gapInput.addEventListener('input', e=>applyGap(e.target.value));
      paletteSelect.addEventListener('change', e=>{ window._paletteApply(e.target.value); });
      resetColors.addEventListener('click', ()=>{ paletteSelect.value='standard'; window._paletteApply('standard'); });
      // initial
      applySize(sizeInput.value); applyGap(gapInput.value);
    })();

    // ----------------- 複製按鈕 -----------------
    (function(){ function copy(text){ if(navigator.clipboard && window.isSecureContext) return navigator.clipboard.writeText(text); const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); return Promise.resolve(); }
      document.addEventListener('click', async (e)=>{
        const cbtn = e.target.closest('[data-copy]'); if(cbtn){ const val=cbtn.getAttribute('data-copy'); try{ await copy(val); cbtn.textContent='已複製'; setTimeout(()=>cbtn.textContent='複製',900); }catch{ cbtn.textContent='複製失敗'; setTimeout(()=>cbtn.textContent='複製',900);} return; }
        const algoBtn = e.target.closest('.algoBtn'); if(!algoBtn) return; const algo = algoBtn.dataset.algo; // copy + play
        try{ await copy(algo); }catch(e){}
        playSequence(algo.split(/\s+|,\s*/));
      });
    })();

    // ----------------- 播放引擎（視覺化示意） -----------------
    let playState = {timer:null, idx:0, seq:[], running:false, paused:false};
    const movesContainer = document.getElementById('movesContainer');
    const speedRange = document.getElementById('speedRange');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');

    function normalizeMoves(arr){ // 清理空項、將小寫 f 轉為 F etc.
      return arr.map(s=>s.trim()).filter(Boolean).map(s=>s.replace(/\u2019/g, "'").replace(/–/g,'-'));
    }

    function renderMoves(seq){ movesContainer.innerHTML = ''; seq.forEach((m,i)=>{ const el=document.createElement('div'); el.className='move'; el.textContent = m; el.dataset.idx=i; movesContainer.appendChild(el); }); }

    function highlight(idx){ Array.from(movesContainer.children).forEach(ch=>ch.classList.toggle('active', Number(ch.dataset.idx)===idx)); }

    function applyVisualMove(move){
      // 視覺上，我們用小幅度的整體旋轉 + 快速閃動以表達「面轉動」的感覺，而非完整狀態變更
      const cube = document.getElementById('cube');
      const orig = cube.style.transform;
      const ang = 90; let tx=0, ty=0, tz=0;
      // map face to camera-space rotations for visual cue
      if(/^R/.test(move)) { ty += -20; }
      else if(/^L/.test(move)) { ty += 20; }
      else if(/^U/.test(move)) { tx += 20; }
      else if(/^D/.test(move)) { tx += -20; }
      else if(/^F/.test(move)) { tz += 0; tx += -10; }
      else if(/^B/.test(move)) { tz += 0; tx += 10; }
      // inverses and 2x
      if(move.includes("'")) { tx *= -1; ty *= -1; }
      if(move.includes('2')) { tx *= 1.6; ty *= 1.6; }

      cube.style.transition = 'transform 180ms ease';
      cube.style.transform = `rotateX(${tx}deg) rotateY(${ty}deg) scale(1)`;
      setTimeout(()=>{ cube.style.transform = orig; cube.style.transition = 'transform 120ms ease'; }, 220);
    }

    async function playSequence(seqRaw){
      const seq = normalizeMoves(seqRaw);
      if(seq.length===0) return;
      if(playState.running) stopPlayback();
      playState.seq = seq; playState.idx = 0; playState.running = true; playState.paused = false;
      renderMoves(seq); highlight(0);
      const delay = ()=>Number(speedRange.value);
      while(playState.idx < seq.length && playState.running){
        if(playState.paused){ await new Promise(r=>setTimeout(r,80)); continue; }
        const m = seq[playState.idx]; highlight(playState.idx); applyVisualMove(m);
        await new Promise(r=>setTimeout(r, delay()));
        playState.idx++;
      }
      playState.running = false;
    }

    function stopPlayback(){ playState.running=false; playState.paused=false; playState.idx=0; highlight(-1); }
    pauseBtn.addEventListener('click', ()=>{ if(!playState.running) return; playState.paused = !playState.paused; pauseBtn.textContent = playState.paused? '繼續' : '暫停'; });
    stopBtn.addEventListener('click', ()=>{ stopPlayback(); });

    document.getElementById('playCustom').addEventListener('click', ()=>{ const v=document.getElementById('customAlgo').value; if(!v) return; playSequence(v.split(/\s+|,\s*/)); });
    document.getElementById('copyCustom').addEventListener('click', async ()=>{ const v=document.getElementById('customAlgo').value; try{ await navigator.clipboard.writeText(v); alert('已複製'); }catch{ alert('複製失敗'); } });

    // small utility: playSequence from other handlers
    window.playSequence = playSequence;

    // stop on page hide
    window.addEventListener('pagehide', ()=>stopPlayback());
  </script></body>
</html>