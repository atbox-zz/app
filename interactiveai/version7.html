<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å…­æ ¹ç¥ç¶“ç¶²çµ¡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1 {
            color: white;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: clamp(18px, 5vw, 28px);
            text-align: center;
        }
        
        .stats {
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            margin-bottom: 10px;
            text-align: center;
            opacity: 0.9;
        }
        
        .canvas-container {
            width: 100%;
            max-width: 1200px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            touch-action: none;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: pointer;
        }
        
        .controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            padding: 0 10px;
        }
        
        button {
            padding: 15px 20px;
            font-size: clamp(14px, 3.5vw, 16px);
            background: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 600;
            touch-action: manipulation;
        }
        
        button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .info {
            color: white;
            margin-top: 15px;
            text-align: center;
            font-size: clamp(12px, 3vw, 14px);
            opacity: 0.9;
            padding: 0 20px;
            line-height: 1.5;
        }
        
        #explanation {
            max-width: 800px;
            width: 100%;
            margin-top: 20px;
            padding: 0 10px;
        }
        
        .explanation-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .explanation-content h2 {
            color: #1e3c72;
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
            border-bottom: 3px solid #4ECDC4;
            padding-bottom: 10px;
        }
        
        .explanation-content h3 {
            color: #2a5298;
            font-size: clamp(16px, 3.5vw, 20px);
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .section {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .section p {
            margin: 10px 0;
            color: #333;
            font-size: clamp(14px, 3vw, 16px);
        }
        
        .section ul {
            list-style: none;
            padding-left: 0;
        }
        
        .section li {
            margin: 12px 0;
            padding-left: 25px;
            position: relative;
            color: #444;
            font-size: clamp(13px, 3vw, 15px);
        }
        
        .section li:before {
            content: "â†’";
            position: absolute;
            left: 5px;
            color: #4ECDC4;
            font-weight: bold;
        }
        
        .try-it {
            background: linear-gradient(135deg, #4ECDC4 0%, #45B7D1 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: clamp(14px, 3vw, 16px);
            line-height: 1.6;
        }
        
        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            
            h1 {
                margin-bottom: 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 12px 16px;
            }
        }
    </style>
</head>
<body>
    <h1>å…­æ ¹å…¥å¤§è…¦ç¥ç¶“ç¶²çµ¡</h1>
    <div class="stats">çœ¼è€³é¼»èˆŒèº«æ„ â†’ å¤§è…¦è™•ç†ä¸­å¿ƒ</div>
    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="controls">
        <button onclick="animateSignal()">ç”±ä¸Šè€Œä¸‹ç™¼é€</button>
        <button onclick="continuousAnimation()">é€£çºŒæ¨¡å¼</button>
        <button onclick="stopAnimation()">åœæ­¢</button>
        <button onclick="toggleExplanation()">æ•™å­¸èªªæ˜</button>
    </div>
    <div class="info">ä¸€æ¬¡ä¸€å€‹æ„Ÿå®˜ï¼Œç”±ä¸Šè€Œä¸‹æ…¢æ…¢ç™¼é€ä¿¡è™Ÿåˆ°å¤§è…¦ï¼ˆå«éŸ³æ•ˆï¼‰</div>
    
    <div id="explanation" style="display: none;">
        <div class="explanation-content">
            <h2>ğŸ§  å…­æ ¹èˆ‡å¤§è…¦çš„ç¥ç¶“ç¶²çµ¡</h2>
            
            <div class="section">
                <h3>ğŸ’¡ ä»€éº¼æ˜¯ã€Œå…­æ ¹ã€ï¼Ÿ</h3>
                <p>ä½›æ•™å’Œä¸­é†«éƒ½æåˆ°äººæœ‰<strong>ã€Œå…­æ ¹ã€</strong>ï¼Œä¹Ÿå°±æ˜¯æˆ‘å€‘æ„ŸçŸ¥ä¸–ç•Œçš„å…­å€‹ç®¡é“ï¼š</p>
                <ul>
                    <li>ğŸ‘ï¸ <strong>çœ¼</strong>ï¼šè¦–è¦ºï¼Œçœ‹è¦‹å…‰ç·šã€é¡è‰²ã€å½¢ç‹€</li>
                    <li>ğŸ‘‚ <strong>è€³</strong>ï¼šè½è¦ºï¼Œè½è¦‹è²éŸ³ã€éŸ³æ¨‚ã€èªè¨€</li>
                    <li>ğŸ‘ƒ <strong>é¼»</strong>ï¼šå—…è¦ºï¼Œèåˆ°é¦™å‘³ã€è‡­å‘³</li>
                    <li>ğŸ‘… <strong>èˆŒ</strong>ï¼šå‘³è¦ºï¼Œåšåˆ°é…¸ç”œè‹¦è¾£é¹¹</li>
                    <li>âœ‹ <strong>èº«</strong>ï¼šè§¸è¦ºï¼Œæ„Ÿå—æº«åº¦ã€ç—›è¦ºã€å£“åŠ›</li>
                    <li>ğŸ§˜ <strong>æ„</strong>ï¼šæ„è­˜ï¼Œæ€è€ƒã€è¨˜æ†¶ã€æƒ…æ„Ÿ</li>
                </ul>
            </div>
            
            <div class="section">
                <h3>âš¡ ç¥ç¶“ç¶²çµ¡å¦‚ä½•é‹ä½œï¼Ÿ</h3>
                <p><strong>ç¬¬1æ­¥ï¼šæ„Ÿå®˜æ¥æ”¶</strong><br>
                å…­æ ¹ä¸æ–·æ¥æ”¶å¤–ç•Œçš„å„ç¨®åˆºæ¿€ï¼Œè½‰æ›æˆç¥ç¶“é›»ä¿¡è™Ÿ</p>
                
                <p><strong>ç¬¬2æ­¥ï¼šå¤šå±¤è™•ç†</strong><br>
                ä¿¡è™Ÿç¶“éä¸‰å±¤ç¥ç¶“ç¶²çµ¡ï¼Œé€æ­¥æ•´åˆå’Œåˆ†æï¼š<br>
                â€¢ ç¬¬ä¸€å±¤ï¼šåˆæ­¥è­˜åˆ¥ï¼ˆé€™æ˜¯ä»€éº¼è²éŸ³ï¼Ÿï¼‰<br>
                â€¢ ç¬¬äºŒå±¤ï¼šç‰¹å¾µæå–ï¼ˆæ˜¯äººè²é‚„æ˜¯éŸ³æ¨‚ï¼Ÿï¼‰<br>
                â€¢ ç¬¬ä¸‰å±¤ï¼šæ·±åº¦ç†è§£ï¼ˆæ˜¯èª°åœ¨èªªä»€éº¼è©±ï¼Ÿï¼‰</p>
                
                <p><strong>ç¬¬3æ­¥ï¼šå¤§è…¦çµ±æ•´</strong><br>
                æ‰€æœ‰è™•ç†éçš„ä¿¡æ¯æœ€çµ‚éƒ½åŒ¯é›†åˆ°å¤§è…¦ï¼Œå½¢æˆå®Œæ•´çš„èªçŸ¥å’Œåæ‡‰</p>
            </div>
            
            <div class="section">
                <h3>ğŸŒˆ ç‚ºä»€éº¼éœ€è¦é€™æ¨£çš„è¨­è¨ˆï¼Ÿ</h3>
                <p><strong>å¹³è¡Œè™•ç†</strong>ï¼šå…­ç¨®æ„Ÿå®˜åŒæ™‚å·¥ä½œï¼Œä¸æœƒäº’ç›¸å¹²æ“¾<br>
                ä¾‹å¦‚ï¼šä½ å¯ä»¥ä¸€é‚Šçœ‹æ›¸ï¼ˆçœ¼ï¼‰ã€ä¸€é‚Šè½éŸ³æ¨‚ï¼ˆè€³ï¼‰ã€ä¸€é‚Šåƒé›¶é£Ÿï¼ˆèˆŒï¼‰</p>
                
                <p><strong>å¤šå±¤éæ¿¾</strong>ï¼šé¿å…å¤§è…¦è¢«å¤ªå¤šä¿¡æ¯æ·¹æ²’<br>
                ä¾‹å¦‚ï¼šä½ ç¾åœ¨èƒ½æ„Ÿè¦ºåˆ°æ¤…å­çš„å£“åŠ›å—ï¼Ÿé€šå¸¸ä½ ä¸æœƒæ³¨æ„ï¼Œé™¤éæˆ‘æé†’ä½ </p>
                
                <p><strong>æ™ºèƒ½æ•´åˆ</strong>ï¼šå¤§è…¦æœƒç¶œåˆå„ç¨®æ„Ÿå®˜ä¿¡æ¯åšæ±ºç­–<br>
                ä¾‹å¦‚ï¼šçœ‹åˆ°ç´…ç‡ˆï¼ˆçœ¼ï¼‰+è½åˆ°ç…è»Šè²ï¼ˆè€³ï¼‰â†’ å¤§è…¦åˆ¤æ–·ã€Œå±éšªï¼ã€</p>
            </div>
            
            <div class="section">
                <h3>ğŸ”¬ ç§‘å­¸å¯¦ä¾‹</h3>
                <ul>
                    <li>ğŸ“ <strong>å‘³è¦ºå¹»è¦º</strong>ï¼šæ„Ÿå†’æ™‚é¼»å¡ï¼Œæœƒè¦ºå¾—é£Ÿç‰©æ²’å‘³é“ã€‚å› ç‚ºå‘³è¦º70%ä¾†è‡ªå—…è¦ºï¼</li>
                    <li>ğŸ¬ <strong>è¦–è½æ•´åˆ</strong>ï¼šçœ‹é›»å½±æ™‚ï¼Œè²éŸ³å’Œç•«é¢åŒæ­¥ï¼Œå¤§è…¦æœƒè¦ºå¾—æ›´çœŸå¯¦</li>
                    <li>ğŸ¨ <strong>è¯è¦º</strong>ï¼šæœ‰äº›äººè½éŸ³æ¨‚æœƒã€Œçœ‹è¦‹ã€é¡è‰²ï¼Œé€™æ˜¯å¤§è…¦å€åŸŸçš„ç‰¹æ®Šé€£çµ</li>
                    <li>ğŸ¥¶ <strong>å¹»è‚¢ç—›</strong>ï¼šå¤±å»æ‰‹è‡‚çš„äººä»æ„Ÿè¦ºç–¼ç—›ï¼Œå› ç‚ºå¤§è…¦çš„ã€Œåœ°åœ–ã€é‚„åœ¨</li>
                </ul>
            </div>
            
            <div class="section">
                <h3>ğŸ¯ ç¾ä»£AIçš„æ‡‰ç”¨</h3>
                <p>æ¨¡ä»¿äººé¡å…­æ ¹çš„AIç³»çµ±ï¼š</p>
                <ul>
                    <li>ğŸ¤– <strong>è‡ªå‹•é§•é§›</strong>ï¼šçµåˆæ”å½±æ©Ÿï¼ˆçœ¼ï¼‰ã€é›·é”ï¼ˆè§¸è¦ºï¼‰ã€éº¥å…‹é¢¨ï¼ˆè€³ï¼‰</li>
                    <li>ğŸ“± <strong>æ™ºæ…§å‹æ‰‹æ©Ÿ</strong>ï¼šSiriåŒæ™‚è™•ç†èªéŸ³ã€è§¸æ§ã€è¦–è¦ºè¼¸å…¥</li>
                    <li>ğŸ  <strong>æ™ºæ…§å®¶å±…</strong>ï¼šæ•´åˆæº«åº¦ã€è²éŸ³ã€å½±åƒæ„Ÿæ¸¬å™¨</li>
                    <li>ğŸ® <strong>VR/AR</strong>ï¼šæ¨¡æ“¬è¦–è¦ºã€è½è¦ºã€ç”šè‡³è§¸è¦ºå›é¥‹</li>
                </ul>
            </div>
            
            <div class="try-it">
                <strong>ğŸ’¡ ç¾åœ¨è©¦è©¦çœ‹ï¼š</strong><br>
                é»æ“Šã€Œç”±ä¸Šè€Œä¸‹ç™¼é€ã€ï¼Œè§€å¯Ÿå…­æ ¹å¦‚ä½•ä¸€å€‹æ¥ä¸€å€‹ç™¼é€ä¿¡è™Ÿï¼Œç¶“éç¥ç¶“ç¶²çµ¡å±¤å±¤è™•ç†ï¼Œæœ€å¾Œçµ±æ•´åˆ°å¤§è…¦ï¼<br><br>
                æ³¨æ„è½ï¼šæ¯å€‹æ„Ÿå®˜ç™¼é€æ™‚éƒ½æœ‰ç¨ç‰¹çš„éŸ³æ•ˆ ğŸ”Š
            </div>
            
            <button onclick="toggleExplanation()" style="margin-top: 15px; width: 100%;">é—œé–‰èªªæ˜</button>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // éŸ³æ•ˆç³»çµ±
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        let scale = 1;
        let layers, neuronRadius, layerHeight;
        
        const sixSenses = [
            { emoji: 'ğŸ‘ï¸', name: 'çœ¼ (è¦–è¦º)', color: '#FF6B6B', freq: 523.25 },      // C5
            { emoji: 'ğŸ‘‚', name: 'è€³ (è½è¦º)', color: '#4ECDC4', freq: 587.33 },      // D5
            { emoji: 'ğŸ‘ƒ', name: 'é¼» (å—…è¦º)', color: '#45B7D1', freq: 659.25 },      // E5
            { emoji: 'ğŸ‘…', name: 'èˆŒ (å‘³è¦º)', color: '#F7DC6F', freq: 698.46 },      // F5
            { emoji: 'âœ‹', name: 'èº« (è§¸è¦º)', color: '#BB8FCE', freq: 783.99 },      // G5
            { emoji: 'ğŸ§˜', name: 'æ„ (æ„è­˜)', color: '#F8B739', freq: 880.00 }       // A5
        ];
        
        function initCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = Math.min(width * 0.7, window.innerHeight * 0.7);
            
            canvas.width = width;
            canvas.height = height;
            
            scale = width / 1200;
            neuronRadius = 25 * scale;
            layerHeight = height * 0.8;
            
            layers = [
                { name: 'å…­æ ¹è¼¸å…¥', x: width * 0.1, neurons: 6, type: 'input' },
                { name: 'ç¥ç¶“å±¤ 1', x: width * 0.33, neurons: 2000, type: 'hidden' },
                { name: 'ç¥ç¶“å±¤ 2', x: width * 0.56, neurons: 2500, type: 'hidden' },
                { name: 'ç¥ç¶“å±¤ 3', x: width * 0.79, neurons: 1500, type: 'hidden' },
                { name: 'å¤§è…¦', x: width * 0.92, neurons: 1, type: 'output' }
            ];
        }
        
        let animating = false;
        let continuousMode = false;
        let currentSense = -1;
        let signalProgress = 0;
        let activeConnections = [];
        let layerColors = new Map();
        
        function getNeuronY(layerIndex, neuronIndex) {
            const layer = layers[layerIndex];
            if (layer.type === 'input') {
                const spacing = layerHeight / (layer.neurons + 1);
                return canvas.height * 0.1 + spacing * (neuronIndex + 1);
            } else if (layer.type === 'output') {
                return canvas.height / 2;
            } else {
                const spacing = layerHeight / layer.neurons;
                return canvas.height * 0.1 + spacing * neuronIndex + spacing / 2;
            }
        }
        
        function drawBrain(x, y, size, isActive, glowColor) {
            ctx.save();
            
            ctx.beginPath();
            ctx.ellipse(x, y, size * 1.2, size, 0, 0, Math.PI * 2);
            
            if (isActive) {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 1.2);
                gradient.addColorStop(0, glowColor || '#FFB6C1');
                gradient.addColorStop(0.5, '#FF69B4');
                gradient.addColorStop(1, '#FF1493');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 25 * scale;
                ctx.shadowColor = glowColor || '#FF69B4';
            } else {
                ctx.fillStyle = '#FFB6C1';
            }
            
            ctx.fill();
            ctx.strokeStyle = '#C71585';
            ctx.lineWidth = 3 * scale;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = isActive ? '#FF1493' : '#C71585';
            ctx.lineWidth = 2 * scale;
            
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x - size * 0.3, y - size * 0.4 + i * size * 0.4, size * 0.3, 0.2, Math.PI - 0.2);
                ctx.stroke();
            }
            
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x + size * 0.3, y - size * 0.4 + i * size * 0.4, size * 0.3, 0.2, Math.PI - 0.2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½é€£æ¥ç·š
            activeConnections.forEach(conn => {
                ctx.beginPath();
                ctx.moveTo(conn.x1, conn.y1);
                ctx.lineTo(conn.x2, conn.y2);
                
                const gradient = ctx.createLinearGradient(conn.x1, conn.y1, conn.x2, conn.y2);
                gradient.addColorStop(0, conn.color);
                gradient.addColorStop(1, conn.toColor || conn.color);
                
                ctx.strokeStyle = gradient;
                ctx.globalAlpha = conn.alpha;
                ctx.lineWidth = conn.width * scale;
                ctx.stroke();
            });
            
            ctx.globalAlpha = 1;
            
            // ç¹ªè£½å„å±¤
            layers.forEach((layer, layerIndex) => {
                if (layer.type === 'input') {
                    // ç¹ªè£½å…­æ ¹
                    for (let i = 0; i < layer.neurons; i++) {
                        const x = layer.x;
                        const y = getNeuronY(layerIndex, i);
                        const sense = sixSenses[i];
                        const isActive = currentSense === i;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                        ctx.fillStyle = isActive ? sense.color : '#E8E8E8';
                        if (isActive) {
                            ctx.shadowBlur = 20 * scale;
                            ctx.shadowColor = sense.color;
                        }
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2 * scale;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        ctx.font = `${neuronRadius * 1.2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(sense.emoji, x, y);
                        
                        ctx.font = `${Math.max(10, 12 * scale)}px Arial`;
                        ctx.fillStyle = '#333';
                        ctx.fillText(sense.name, x, y + neuronRadius + 15 * scale);
                    }
                } else if (layer.type === 'output') {
                    // ç¹ªè£½å¤§è…¦
                    const x = layer.x;
                    const y = getNeuronY(layerIndex, 0);
                    const isActive = signalProgress >= 4;
                    const glowColor = currentSense >= 0 ? sixSenses[currentSense].color : null;
                    drawBrain(x, y, neuronRadius * 2, isActive, glowColor);
                    
                    ctx.font = `bold ${Math.max(12, 16 * scale)}px Arial`;
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ§  å¤§è…¦', x, y + neuronRadius * 2.5 + 15 * scale);
                } else {
                    // éš±è—å±¤ - é¡¯ç¤ºé¡è‰²è®ŠåŒ–
                    const layerColor = layerColors.get(layerIndex);
                    const isActive = layerColor && layerColor.alpha > 0;
                    
                    if (isActive) {
                        // ç¹ªè£½ç™¼å…‰çš„ç¥ç¶“å…ƒé»
                        for (let i = 0; i < 50; i++) {
                            const y = getNeuronY(layerIndex, Math.random() * layer.neurons);
                            ctx.beginPath();
                            ctx.arc(layer.x, y, 2 * scale, 0, Math.PI * 2);
                            ctx.fillStyle = layerColor.color;
                            ctx.shadowBlur = 8 * scale;
                            ctx.shadowColor = layerColor.color;
                            ctx.globalAlpha = layerColor.alpha;
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                    
                    // ç¹ªè£½åŸºç¤ç·šæ¢
                    ctx.beginPath();
                    ctx.moveTo(layer.x, getNeuronY(layerIndex, 0));
                    
                    for (let i = 0; i < Math.min(layer.neurons, 100); i++) {
                        const y = getNeuronY(layerIndex, i * (layer.neurons / 100));
                        ctx.lineTo(layer.x + (i % 2 === 0 ? -2 : 2) * scale, y);
                    }
                    
                    ctx.strokeStyle = isActive ? layerColor.color : '#CCCCCC';
                    ctx.lineWidth = isActive ? 3 * scale : 1.5 * scale;
                    ctx.globalAlpha = isActive ? layerColor.alpha * 0.7 : 1;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });
            
            // ç¹ªè£½å±¤æ¨™ç±¤
            ctx.fillStyle = '#2c3e50';
            ctx.font = `bold ${Math.max(10, 12 * scale)}px Arial`;
            ctx.textAlign = 'center';
            layers.forEach((layer, index) => {
                if (layer.type !== 'input' && layer.type !== 'output') {
                    ctx.fillText(layer.name, layer.x, canvas.height * 0.04);
                }
            });
        }
        
        function animateSignal() {
            if (animating && !continuousMode) return;
            
            animating = true;
            currentSense = 0;
            signalProgress = 0;
            
            function animateSingleSense() {
                if (!animating && !continuousMode) return;
                if (currentSense >= 6) {
                    if (continuousMode) {
                        currentSense = 0;
                        setTimeout(animateSingleSense, 1000);
                    } else {
                        animating = false;
                        setTimeout(() => {
                            currentSense = -1;
                            signalProgress = 0;
                            activeConnections = [];
                            layerColors.clear();
                            drawNetwork();
                        }, 2000);
                    }
                    return;
                }
                
                // æ’­æ”¾è©²æ„Ÿå®˜çš„éŸ³æ•ˆ
                const sense = sixSenses[currentSense];
                playTone(sense.freq, 0.3, 'sine');
                
                signalProgress = 0;
                let step = 0;
                const maxSteps = 50;
                
                function animateStep() {
                    if (!animating && !continuousMode) return;
                    
                    const progress = step / maxSteps;
                    signalProgress = progress * 4;
                    const currentLayer = Math.floor(signalProgress);
                    const layerProgress = signalProgress - currentLayer;
                    
                    activeConnections = [];
                    layerColors.clear();
                    
                    // æ›´æ–°éš±è—å±¤é¡è‰²
                    for (let i = 1; i <= 3; i++) {
                        if (currentLayer >= i) {
                            const alpha = i === currentLayer ? layerProgress : 
                                         (i < currentLayer ? Math.max(0, 1 - (currentLayer - i) * 0.3) : 0);
                            if (alpha > 0) {
                                layerColors.set(i, {
                                    color: sense.color,
                                    alpha: alpha
                                });
                            }
                        }
                    }
                    
                    // å‰µå»ºé€£æ¥ç·š
                    if (currentLayer < 4) {
                        const fromLayer = currentLayer;
                        const toLayer = currentLayer + 1;
                        const numConnections = 80;
                        
                        for (let i = 0; i < numConnections; i++) {
                            let x1, y1, x2, y2;
                            
                            if (fromLayer === 0) {
                                x1 = layers[0].x;
                                y1 = getNeuronY(0, currentSense);
                            } else {
                                x1 = layers[fromLayer].x;
                                y1 = getNeuronY(fromLayer, Math.random() * layers[fromLayer].neurons);
                            }
                            
                            if (toLayer === 4) {
                                x2 = layers[4].x;
                                y2 = getNeuronY(4, 0);
                            } else {
                                x2 = layers[toLayer].x;
                                y2 = getNeuronY(toLayer, Math.random() * layers[toLayer].neurons);
                            }
                            
                            activeConnections.push({
                                x1, y1, x2, y2,
                                color: sense.color,
                                toColor: toLayer === 4 ? '#FF69B4' : sense.color,
                                alpha: Math.min(1, layerProgress * 2) * (0.3 + Math.random() * 0.4),
                                width: 1.5
                            });
                        }
                    }
                    
                    drawNetwork();
                    
                    step++;
                    if (step < maxSteps) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // æ’­æ”¾åˆ°é”å¤§è…¦çš„éŸ³æ•ˆ
                        playTone(1046.5, 0.2, 'triangle');
                        
                        currentSense++;
                        setTimeout(animateSingleSense, 800);
                    }
                }
                
                animateStep();
            }
            
            animateSingleSense();
        }
        
        function continuousAnimation() {
            continuousMode = true;
            if (!animating) {
                animateSignal();
            }
        }
        
        function stopAnimation() {
            continuousMode = false;
            animating = false;
            currentSense = -1;
            signalProgress = 0;
            activeConnections = [];
            layerColors.clear();
            drawNetwork();
        }
        
        function toggleExplanation() {
            const explanation = document.getElementById('explanation');
            if (explanation.style.display === 'none') {
                explanation.style.display = 'block';
                explanation.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                explanation.style.display = 'none';
            }
        }
        
        // åˆå§‹åŒ–
        initCanvas();
        drawNetwork();
        
        // éŸ¿æ‡‰å¼èª¿æ•´
        window.addEventListener('resize', () => {
            initCanvas();
            drawNetwork();
        });
        
        // è§¸æ§æ”¯æŒ
        canvas.addEventListener('click', () => {
            if (!continuousMode && !animating) {
                animateSignal();
            }
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!continuousMode && !animating) {
                animateSignal();
            }
        });
    </script>
</body>
</html>